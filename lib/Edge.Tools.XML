<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Edge.Tools</name>
    </assembly>
    <members>
        <member name="T:Edge.Tools.Attributes.CanBeNullAttribute">
            <summary>
            Indicates that the value of the marked element could be <c>null</c> sometimes,
            so the check for <c>null</c> is necessary before its usage
            </summary>
            <example><code>
            [CanBeNull] public object Test() { return null; }
            public void UseTest() {
              var p = Test();
              var s = p.ToString(); // Warning: Possible 'System.NullReferenceException'
            }
            </code></example>
        </member>
        <member name="T:Edge.Tools.Attributes.NotNullAttribute">
            <summary>
            Indicates that the value of the marked element could never be <c>null</c>
            </summary>
            <example><code>
            [NotNull] public object Foo() {
              return null; // Warning: Possible 'null' assignment
            }
            </code></example>
        </member>
        <member name="T:Edge.Tools.Attributes.ItemNotNullAttribute">
            <summary>
            Indicates that collection or enumerable value does not contain null elements
            </summary>
        </member>
        <member name="T:Edge.Tools.Attributes.ItemCanBeNullAttribute">
            <summary>
            Indicates that collection or enumerable value can contain null elements
            </summary>
        </member>
        <member name="T:Edge.Tools.Attributes.StringFormatMethodAttribute">
            <summary>
            Indicates that the marked method builds string by format pattern and (optional) arguments.
            Parameter, which contains format string, should be given in constructor. The format string
            should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/>-like form
            </summary>
            <example><code>
            [StringFormatMethod("message")]
            public void ShowError(string message, params object[] args) { /* do something */ }
            public void Foo() {
              ShowError("Failed: {0}"); // Warning: Non-existing argument in format string
            }
            </code></example>
        </member>
        <member name="M:Edge.Tools.Attributes.StringFormatMethodAttribute.#ctor(System.String)">
            <param name="formatParameterName">
            Specifies which parameter of an annotated method should be treated as format-string
            </param>
        </member>
        <member name="T:Edge.Tools.Attributes.ValueProviderAttribute">
            <summary>
            For a parameter that is expected to be one of the limited set of values.
            Specify fields of which type should be used as values for this parameter.
            </summary>
        </member>
        <member name="T:Edge.Tools.Attributes.InvokerParameterNameAttribute">
            <summary>
            Indicates that the function argument should be string literal and match one
            of the parameters of the caller function. For example, ReSharper annotates
            the parameter of <see cref="T:System.ArgumentNullException"/>
            </summary>
            <example><code>
            public void Foo(string param) {
              if (param == null)
                throw new ArgumentNullException("par"); // Warning: Cannot resolve symbol
            }
            </code></example>
        </member>
        <member name="T:Edge.Tools.Attributes.NotifyPropertyChangedInvocatorAttribute">
             <summary>
             Indicates that the method is contained in a type that implements
             <c>System.ComponentModel.INotifyPropertyChanged</c> interface and this method
             is used to notify that some property value changed
             </summary>
             <remarks>
             The method should be non-static and conform to one of the supported signatures:
             <list>
             <item><c>NotifyChanged(string)</c></item>
             <item><c>NotifyChanged(params string[])</c></item>
             <item><c>NotifyChanged{T}(Expression{Func{T}})</c></item>
             <item><c>NotifyChanged{T,U}(Expression{Func{T,U}})</c></item>
             <item><c>SetProperty{T}(ref T, T, string)</c></item>
             </list>
             </remarks>
             <example><code>
             public class Foo : INotifyPropertyChanged {
               public event PropertyChangedEventHandler PropertyChanged;
               [NotifyPropertyChangedInvocator]
               protected virtual void NotifyChanged(string propertyName) { ... }
            
               private string _name;
               public string Name {
                 get { return _name; }
                 set { _name = value; NotifyChanged("LastName"); /* Warning */ }
               }
             }
             </code>
             Examples of generated notifications:
             <list>
             <item><c>NotifyChanged("Property")</c></item>
             <item><c>NotifyChanged(() =&gt; Property)</c></item>
             <item><c>NotifyChanged((VM x) =&gt; x.Property)</c></item>
             <item><c>SetProperty(ref myField, value, "Property")</c></item>
             </list>
             </example>
        </member>
        <member name="T:Edge.Tools.Attributes.ContractAnnotationAttribute">
            <summary>
            Describes dependency between method input and output
            </summary>
            <syntax>
            <p>Function Definition Table syntax:</p>
            <list>
            <item>FDT      ::= FDTRow [;FDTRow]*</item>
            <item>FDTRow   ::= Input =&gt; Output | Output &lt;= Input</item>
            <item>Input    ::= ParameterName: Value [, Input]*</item>
            <item>Output   ::= [ParameterName: Value]* {halt|stop|void|nothing|Value}</item>
            <item>Value    ::= true | false | null | notnull | canbenull</item>
            </list>
            If method has single input parameter, it's name could be omitted.<br/>
            Using <c>halt</c> (or <c>void</c>/<c>nothing</c>, which is the same)
            for method output means that the methos doesn't return normally.<br/>
            <c>canbenull</c> annotation is only applicable for output parameters.<br/>
            You can use multiple <c>[ContractAnnotation]</c> for each FDT row,
            or use single attribute with rows separated by semicolon.<br/>
            </syntax>
            <examples><list>
            <item><code>
            [ContractAnnotation("=> halt")]
            public void TerminationMethod()
            </code></item>
            <item><code>
            [ContractAnnotation("halt &lt;= condition: false")]
            public void Assert(bool condition, string text) // regular assertion method
            </code></item>
            <item><code>
            [ContractAnnotation("s:null => true")]
            public bool IsNullOrEmpty(string s) // string.IsNullOrEmpty()
            </code></item>
            <item><code>
            // A method that returns null if the parameter is null,
            // and not null if the parameter is not null
            [ContractAnnotation("null => null; notnull => notnull")]
            public object Transform(object data) 
            </code></item>
            <item><code>
            [ContractAnnotation("s:null=>false; =>true,result:notnull; =>false, result:null")]
            public bool TryParse(string s, out Person result)
            </code></item>
            </list></examples>
        </member>
        <member name="T:Edge.Tools.Attributes.LocalizationRequiredAttribute">
            <summary>
            Indicates that marked element should be localized or not
            </summary>
            <example><code>
            [LocalizationRequiredAttribute(true)]
            public class Foo {
              private string str = "my string"; // Warning: Localizable string
            }
            </code></example>
        </member>
        <member name="T:Edge.Tools.Attributes.CannotApplyEqualityOperatorAttribute">
            <summary>
            Indicates that the value of the marked type (or its derivatives)
            cannot be compared using '==' or '!=' operators and <c>Equals()</c>
            should be used instead. However, using '==' or '!=' for comparison
            with <c>null</c> is always permitted.
            </summary>
            <example><code>
            [CannotApplyEqualityOperator]
            class NoEquality { }
            class UsesNoEquality {
              public void Test() {
                var ca1 = new NoEquality();
                var ca2 = new NoEquality();
                if (ca1 != null) { // OK
                  bool condition = ca1 == ca2; // Warning
                }
              }
            }
            </code></example>
        </member>
        <member name="T:Edge.Tools.Attributes.BaseTypeRequiredAttribute">
            <summary>
            When applied to a target attribute, specifies a requirement for any type marked
            with the target attribute to implement or inherit specific type or types.
            </summary>
            <example><code>
            [BaseTypeRequired(typeof(IComponent)] // Specify requirement
            public class ComponentAttribute : Attribute { }
            [Component] // ComponentAttribute requires implementing IComponent interface
            public class MyComponent : IComponent { }
            </code></example>
        </member>
        <member name="T:Edge.Tools.Attributes.UsedImplicitlyAttribute">
            <summary>
            Indicates that the marked symbol is used implicitly
            (e.g. via reflection, in external library), so this symbol
            will not be marked as unused (as well as by other usage inspections)
            </summary>
        </member>
        <member name="T:Edge.Tools.Attributes.MeansImplicitUseAttribute">
            <summary>
            Should be used on attributes and causes ReSharper
            to not mark symbols marked with such attributes as unused
            (as well as by other usage inspections)
            </summary>
        </member>
        <member name="F:Edge.Tools.Attributes.ImplicitUseKindFlags.Access">
            <summary>Only entity marked with attribute considered used</summary>
        </member>
        <member name="F:Edge.Tools.Attributes.ImplicitUseKindFlags.Assign">
            <summary>Indicates implicit assignment to a member</summary>
        </member>
        <member name="F:Edge.Tools.Attributes.ImplicitUseKindFlags.InstantiatedWithFixedConstructorSignature">
            <summary>
            Indicates implicit instantiation of a type with fixed constructor signature.
            That means any unused constructor parameters won't be reported as such.
            </summary>
        </member>
        <member name="F:Edge.Tools.Attributes.ImplicitUseKindFlags.InstantiatedNoFixedConstructorSignature">
            <summary>Indicates implicit instantiation of a type</summary>
        </member>
        <member name="T:Edge.Tools.Attributes.ImplicitUseTargetFlags">
            <summary>
            Specify what is considered used implicitly when marked
            with <see cref="T:Edge.Tools.Attributes.MeansImplicitUseAttribute"/> or <see cref="T:Edge.Tools.Attributes.UsedImplicitlyAttribute"/>
            </summary>
        </member>
        <member name="F:Edge.Tools.Attributes.ImplicitUseTargetFlags.Members">
            <summary>Members of entity marked with attribute are considered used</summary>
        </member>
        <member name="F:Edge.Tools.Attributes.ImplicitUseTargetFlags.WithMembers">
            <summary>Entity marked with attribute and all its members considered used</summary>
        </member>
        <member name="T:Edge.Tools.Attributes.PublicAPIAttribute">
            <summary>
            This attribute is intended to mark publicly available API
            which should not be removed and so is treated as used
            </summary>
        </member>
        <member name="T:Edge.Tools.Attributes.InstantHandleAttribute">
            <summary>
            Tells code analysis engine if the parameter is completely handled
            when the invoked method is on stack. If the parameter is a delegate,
            indicates that delegate is executed while the method is executed.
            If the parameter is an enumerable, indicates that it is enumerated
            while the method is executed
            </summary>
        </member>
        <member name="T:Edge.Tools.Attributes.PureAttribute">
            <summary>
            Indicates that a method does not make any observable state changes.
            The same as <c>System.Diagnostics.Contracts.PureAttribute</c>
            </summary>
            <example><code>
            [Pure] private int Multiply(int x, int y) { return x * y; }
            public void Foo() {
              const int a = 2, b = 2;
              Multiply(a, b); // Waring: Return value of pure method is not used
            }
            </code></example>
        </member>
        <member name="T:Edge.Tools.Attributes.PathReferenceAttribute">
            <summary>
            Indicates that a parameter is a path to a file or a folder within a web project.
            Path can be relative or absolute, starting from web root (~)
            </summary>
        </member>
        <member name="T:Edge.Tools.Attributes.AspMvcActionAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC action. If applied to a method, the MVC action name is calculated
            implicitly from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:Edge.Tools.Attributes.AspMvcAreaAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC area.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:Edge.Tools.Attributes.AspMvcControllerAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter is
            an MVC controller. If applied to a method, the MVC controller name is calculated
            implicitly from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String, String)</c>
            </summary>
        </member>
        <member name="T:Edge.Tools.Attributes.AspMvcMasterAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC Master. Use this attribute
            for custom wrappers similar to <c>System.Web.Mvc.Controller.View(String, String)</c>
            </summary>
        </member>
        <member name="T:Edge.Tools.Attributes.AspMvcModelTypeAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC model type. Use this attribute
            for custom wrappers similar to <c>System.Web.Mvc.Controller.View(String, Object)</c>
            </summary>
        </member>
        <member name="T:Edge.Tools.Attributes.AspMvcPartialViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter is an MVC
            partial view. If applied to a method, the MVC partial view name is calculated implicitly
            from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.RenderPartialExtensions.RenderPartial(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:Edge.Tools.Attributes.AspMvcSupressViewErrorAttribute">
            <summary>
            ASP.NET MVC attribute. Allows disabling inspections for MVC views within a class or a method
            </summary>
        </member>
        <member name="T:Edge.Tools.Attributes.AspMvcDisplayTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC display template.
            Use this attribute for custom wrappers similar to 
            <c>System.Web.Mvc.Html.DisplayExtensions.DisplayForModel(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:Edge.Tools.Attributes.AspMvcEditorTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC editor template.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.EditorExtensions.EditorForModel(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:Edge.Tools.Attributes.AspMvcTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC template.
            Use this attribute for custom wrappers similar to
            <c>System.ComponentModel.DataAnnotations.UIHintAttribute(System.String)</c>
            </summary>
        </member>
        <member name="T:Edge.Tools.Attributes.AspMvcViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC view. If applied to a method, the MVC view name is calculated implicitly
            from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Controller.View(Object)</c>
            </summary>
        </member>
        <member name="T:Edge.Tools.Attributes.AspMvcActionSelectorAttribute">
            <summary>
            ASP.NET MVC attribute. When applied to a parameter of an attribute,
            indicates that this parameter is an MVC action name
            </summary>
            <example><code>
            [ActionName("Foo")]
            public ActionResult Login(string returnUrl) {
              ViewBag.ReturnUrl = Url.Action("Foo"); // OK
              return RedirectToAction("Bar"); // Error: Cannot resolve action
            }
            </code></example>
        </member>
        <member name="T:Edge.Tools.Attributes.RazorSectionAttribute">
            <summary>
            Razor attribute. Indicates that a parameter or a method is a Razor section.
            Use this attribute for custom wrappers similar to 
            <c>System.Web.WebPages.WebPageBase.RenderSection(String)</c>
            </summary>
        </member>
        <member name="T:Edge.Tools.Attributes.CollectionAccessAttribute">
            <summary>
            Indicates how method invocation affects content of the collection
            </summary>
        </member>
        <member name="F:Edge.Tools.Attributes.CollectionAccessType.None">
            <summary>Method does not use or modify content of the collection</summary>
        </member>
        <member name="F:Edge.Tools.Attributes.CollectionAccessType.Read">
            <summary>Method only reads content of the collection but does not modify it</summary>
        </member>
        <member name="F:Edge.Tools.Attributes.CollectionAccessType.ModifyExistingContent">
            <summary>Method can change content of the collection but does not add new elements</summary>
        </member>
        <member name="F:Edge.Tools.Attributes.CollectionAccessType.UpdatedContent">
            <summary>Method can add new elements to the collection</summary>
        </member>
        <member name="T:Edge.Tools.Attributes.AssertionMethodAttribute">
            <summary>
            Indicates that the marked method is assertion method, i.e. it halts control flow if
            one of the conditions is satisfied. To set the condition, mark one of the parameters with 
            <see cref="T:Edge.Tools.Attributes.AssertionConditionAttribute"/> attribute
            </summary>
        </member>
        <member name="T:Edge.Tools.Attributes.AssertionConditionAttribute">
            <summary>
            Indicates the condition parameter of the assertion method. The method itself should be
            marked by <see cref="T:Edge.Tools.Attributes.AssertionMethodAttribute"/> attribute. The mandatory argument of
            the attribute is the assertion type.
            </summary>
        </member>
        <member name="T:Edge.Tools.Attributes.AssertionConditionType">
            <summary>
            Specifies assertion type. If the assertion method argument satisfies the condition,
            then the execution continues. Otherwise, execution is assumed to be halted
            </summary>
        </member>
        <member name="F:Edge.Tools.Attributes.AssertionConditionType.IS_TRUE">
            <summary>Marked parameter should be evaluated to true</summary>
        </member>
        <member name="F:Edge.Tools.Attributes.AssertionConditionType.IS_FALSE">
            <summary>Marked parameter should be evaluated to false</summary>
        </member>
        <member name="F:Edge.Tools.Attributes.AssertionConditionType.IS_NULL">
            <summary>Marked parameter should be evaluated to null value</summary>
        </member>
        <member name="F:Edge.Tools.Attributes.AssertionConditionType.IS_NOT_NULL">
            <summary>Marked parameter should be evaluated to not null value</summary>
        </member>
        <member name="T:Edge.Tools.Attributes.TerminatesProgramAttribute">
            <summary>
            Indicates that the marked method unconditionally terminates control flow execution.
            For example, it could unconditionally throw exception
            </summary>
        </member>
        <member name="T:Edge.Tools.Attributes.LinqTunnelAttribute">
            <summary>
            Indicates that method is pure LINQ method, with postponed enumeration (like Enumerable.Select,
            .Where). This annotation allows inference of [InstantHandle] annotation for parameters
            of delegate type by analyzing LINQ method chains.
            </summary>
        </member>
        <member name="T:Edge.Tools.Attributes.NoEnumerationAttribute">
            <summary>
            Indicates that IEnumerable, passed as parameter, is not enumerated.
            </summary>
        </member>
        <member name="T:Edge.Tools.Attributes.RegexPatternAttribute">
            <summary>
            Indicates that parameter is regular expression pattern.
            </summary>
        </member>
        <member name="T:Edge.Tools.Attributes.XamlItemsControlAttribute">
            <summary>
            XAML attribute. Indicates the type that has <c>ItemsSource</c> property and should be
            treated as <c>ItemsControl</c>-derived type, to enable inner  items <c>DataContext</c>
            type resolve.
            </summary>
        </member>
        <member name="T:Edge.Tools.Attributes.XamlItemBindingOfItemsControlAttribute">
            <summary>
            XAML attibute. Indicates the property of some <c>BindingBase</c>-derived type, that
            is used to bind some item of <c>ItemsControl</c>-derived type. This annotation will
            enable the <c>DataContext</c> type resolve for XAML bindings for such properties.
            </summary>
            <remarks>
            Property should have the tree ancestor of the <c>ItemsControl</c> type or
            marked with the <see cref="T:Edge.Tools.Attributes.XamlItemsControlAttribute"/> attribute.
            </remarks>
        </member>
        <member name="T:Edge.Tools.Attributes.NoReorder">
            <summary>
            Prevents the Member Reordering feature from tossing members of the marked class.
            </summary>
            <remarks>
            The attribute must be mentioned in your member reordering patterns.
            </remarks>
        </member>
        <member name="T:Edge.Tools.Cryptography.Base32">
            <summary>
            Class used for conversion between byte array and Base32 notation
            </summary>
        </member>
        <member name="F:Edge.Tools.Cryptography.Base32.InByteSize">
            <summary>
            Size of the regular byte in bits
            </summary>
        </member>
        <member name="F:Edge.Tools.Cryptography.Base32.OutByteSize">
            <summary>
            Size of converted byte in bits
            </summary>
        </member>
        <member name="F:Edge.Tools.Cryptography.Base32.Base32Alphabet">
            <summary>
            Alphabet
            </summary>
        </member>
        <member name="M:Edge.Tools.Cryptography.Base32.ToBase32String(System.Byte[])">
            <summary>
            Convert byte array to Base32 format
            </summary>
            <param name="bytes">An array of bytes to convert to Base32 format</param>
            <returns>Returns a string representing byte array</returns>
        </member>
        <member name="M:Edge.Tools.Cryptography.Base32.FromBase32String(System.String)">
            <summary>
            Convert base32 string to array of bytes
            </summary>
            <param name="base32String">Base32 string to convert</param>
            <returns>Returns a byte array converted from the string</returns>
        </member>
        <member name="T:Edge.Tools.Cryptography.IdCipher">
            <summary>
            Static class for ciphering int id values into keys.
            </summary>
        </member>
        <member name="M:Edge.Tools.Cryptography.IdCipher.GetKeyFromText(System.String)">
            <summary>
            Key text should be at least 8 characters long.
            </summary>
        </member>
        <member name="M:Edge.Tools.Cryptography.IdCipher.LongCipherEncode(System.Int32,System.Byte[])">
            <summary>
            Encrypt and encode given integer with a custom algorithm.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"> When mask length is not 8.</exception>
        </member>
        <member name="M:Edge.Tools.Cryptography.IdCipher.LongCipherDecode(System.String,System.Byte[])">
            <summary>
            Decode and decrypt given value with a custom algorithm to original integer.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"> When mask length is not 8.</exception>
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.ChunkCopyBehaviour">
            <summary>
            Behaviours for chunks transfer when reading and writing.
            </summary>
            <remarks>
            They are bitmasks, can be OR-ed
            </remarks>
        </member>
        <member name="F:Edge.Tools.Images.Png.Chunks.ChunkCopyBehaviour.COPY_NONE">
            <summary>
            Don't copy any chunk
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.Chunks.ChunkCopyBehaviour.COPY_PALETTE">
            <summary>
            Copy the Palette, if present
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.Chunks.ChunkCopyBehaviour.COPY_ALL_SAFE">
            <summary>
            Copy all SAFE chunks
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.Chunks.ChunkCopyBehaviour.COPY_ALL">
            <summary>
            Copy all chunks (includes palette)
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.Chunks.ChunkCopyBehaviour.COPY_PHYS">
            <summary>
            Copy Physical resolution (DPI)
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.Chunks.ChunkCopyBehaviour.COPY_TEXTUAL">
            <summary>
            Copy all textual chunks (not safe)
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.Chunks.ChunkCopyBehaviour.COPY_TRANSPARENCY">
            <summary>
            Copy transparency (not safe)
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.Chunks.ChunkCopyBehaviour.COPY_UNKNOWN">
            <summary>
            Copy chunks unknown by our factory
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.Chunks.ChunkCopyBehaviour.COPY_ALMOSTALL">
            <summary>
            Copy all known, except HIST, TIME and textual
            </summary>
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.ChunkHelper">
            <summary>
            Static utility methods for CHunks
            </summary>
            <remarks>
            Client code should rarely need this, see PngMetada and ChunksList
            </remarks>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunkHelper.ToBytes(System.String)">
            <summary>
            Converts to bytes using Latin1 (ISO-8859-1)
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunkHelper.ToString(System.Byte[])">
            <summary>
            Converts to String using Latin1 (ISO-8859-1)
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunkHelper.ToString(System.Byte[],System.Int32,System.Int32)">
            <summary>
             Converts to String using Latin1 (ISO-8859-1)
            </summary>
            <param name="x"></param>
            <param name="offset"></param>
            <param name="len"></param>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunkHelper.ToBytesUTF8(System.String)">
            <summary>
            Converts to bytes using UTF-8
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunkHelper.ToStringUTF8(System.Byte[])">
            <summary>
            Converts to string using UTF-8
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunkHelper.ToStringUTF8(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Converts to string using UTF-8
            </summary>
            <param name="x"></param>
            <param name="offset"></param>
            <param name="len"></param>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunkHelper.WriteBytesToStream(System.IO.Stream,System.Byte[])">
            <summary>
            Writes full array of bytes to stream
            </summary>
            <param name="stream"></param>
            <param name="bytes"></param>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunkHelper.IsCritical(System.String)">
            <summary>
            Critical chunks: first letter is uppercase
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunkHelper.IsPublic(System.String)">
            <summary>
            Public chunks: second letter is uppercase
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunkHelper.IsSafeToCopy(System.String)">
            <summary>
            Safe to copy chunk: fourth letter is lower case
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunkHelper.IsUnknown(Edge.Tools.Images.Png.Chunks.PngChunk)">
            <summary>
            We consider a chunk as "unknown" if our chunk factory (even when it has been augmented by client code) doesn't recognize it
            </summary>
            <param name="chunk"></param>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunkHelper.PosNullByte(System.Byte[])">
            <summary>
            Finds position of null byte in array
            </summary>
            <param name="bytes"></param>
            <returns>-1 if not found</returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunkHelper.ShouldLoad(System.String,Edge.Tools.Images.Png.Chunks.ChunkLoadBehaviour)">
            <summary>
            Decides if a chunk should be loaded, according to a ChunkLoadBehaviour
            </summary>
            <param name="id"></param>
            <param name="behav"></param>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunkHelper.FilterList(System.Collections.Generic.List{Edge.Tools.Images.Png.Chunks.PngChunk},Edge.Tools.Images.Png.Chunks.ChunkPredicate)">
            <summary>
            Filters a list of Chunks, keeping those which match the predicate
            </summary>
            <remarks>The original list is not altered</remarks>
            <param name="list"></param>
            <param name="predicateKeep"></param>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunkHelper.TrimList(System.Collections.Generic.List{Edge.Tools.Images.Png.Chunks.PngChunk},Edge.Tools.Images.Png.Chunks.ChunkPredicate)">
            <summary>
            Filters a list of Chunks, removing those which match the predicate
            </summary>
            <remarks>The original list is not altered</remarks>
            <param name="list"></param>
            <param name="predicateRemove"></param>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunkHelper.Equivalent(Edge.Tools.Images.Png.Chunks.PngChunk,Edge.Tools.Images.Png.Chunks.PngChunk)">
            <summary>
            Ad-hoc criteria for 'equivalent' chunks.
            </summary>
             <remarks>
            Two chunks are equivalent if they have the same Id AND either:
            1. they are Single
            2. both are textual and have the same key
            3. both are SPLT and have the same palette name
            Bear in mind that this is an ad-hoc, non-standard, nor required (nor wrong)
            criterion. Use it only if you find it useful. Notice that PNG allows to have
            repeated textual keys with same keys.
            </remarks>        
            <param name="c1">Chunk1</param>
            <param name="c2">Chunk1</param>
            <returns>true if equivalent</returns>
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.ChunkLoadBehaviour">
            <summary>
            Defines what to do with non critical chunks when reading
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.Chunks.ChunkLoadBehaviour.LOAD_CHUNK_NEVER">
            <summary>
            all non-critical chunks are skippped
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.Chunks.ChunkLoadBehaviour.LOAD_CHUNK_KNOWN">
            <summary>
            load chunk if 'known' (registered with the factory)
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.Chunks.ChunkLoadBehaviour.LOAD_CHUNK_IF_SAFE">
            <summary>
            load chunk if 'known' or safe to copy 
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.Chunks.ChunkLoadBehaviour.LOAD_CHUNK_ALWAYS">
            <summary>
            load chunks always 
            
             Notice that other restrictions might apply, see PngReader.SkipChunkMaxSize PngReader.SkipChunkIds
            </summary>
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.ChunkPredicate">
            <summary>
            Decides if another chunk "matches", according to some criterion
            </summary>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunkPredicate.Matches(Edge.Tools.Images.Png.Chunks.PngChunk)">
            <summary>
            The other chunk matches with this one
            </summary>
            <param name="chunk">The other chunk</param>
            <returns>true if matches</returns>
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.ChunkPredicateEquiv">
            <summary>
            An ad-hoc criterion, perhaps useful, for equivalence.
            <see cref="M:Edge.Tools.Images.Png.Chunks.ChunkHelper.Equivalent(Edge.Tools.Images.Png.Chunks.PngChunk,Edge.Tools.Images.Png.Chunks.PngChunk)"/> 
            </summary>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunkPredicateEquiv.#ctor(Edge.Tools.Images.Png.Chunks.PngChunk)">
            <summary>
            Creates predicate based of reference chunk
            </summary>
            <param name="chunk"></param>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunkPredicateEquiv.Matches(Edge.Tools.Images.Png.Chunks.PngChunk)">
            <summary>
            Check for match
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.ChunkPredicateId">
            <summary>
            Match if have same Chunk Id
            </summary>
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.ChunkPredicateId2">
            <summary>
            match if have same id and, if Text (or SPLT) if have the asame key
            </summary>
            <remarks>
            This is the same as ChunkPredicateEquivalent, the only difference is that does not requires
            a chunk at construction time
            </remarks>
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.ChunkRaw">
             <summary>
             Wraps the raw chunk data
             </summary>
             <remarks>
             Short lived object, to be created while
             serialing/deserializing 
             
             Do not reuse it for different chunks
             
             See http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html
            </remarks>
        </member>
        <member name="F:Edge.Tools.Images.Png.Chunks.ChunkRaw.IdBytes">
            <summary>
            Chunk Id, as array of 4 bytes
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.Chunks.ChunkRaw.Length">
            <summary>
            The length counts only the data field, not itself, the chunk type code, or the CRC. Zero is a valid length.
            Although encoders and decoders should treat the length as unsigned, its value must not exceed 2^31-1 bytes.
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.Chunks.ChunkRaw.Data">
            <summary>
            Raw data, crc not included
            </summary>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunkRaw.#ctor(System.Int32,System.Byte[],System.Boolean)">
            <summary>
            Creates an empty raw chunk
            </summary>
            <param name="length"></param>
            <param name="idbytes"></param>
            <param name="alloc">pre allocate the data buffer?</param>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunkRaw.ComputeCrc">
            <summary>
            Called after setting data, before writing to os
            </summary>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunkRaw.ReadChunkData(System.IO.Stream,System.Boolean)">
             <summary>
             Position before: just after chunk id. positon after: after crc Data should
             be already allocated. Checks CRC Return number of byte read.
             </summary>
            
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunkRaw.ToString">
            <summary>
            Just id and length
            </summary>
            <returns></returns>
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.ChunksList">
             <summary>
             All chunks that form an image, read or to be written
             
             http://www.w3.org/TR/PNG/#table53
             </summary>
            
        </member>
        <member name="F:Edge.Tools.Images.Png.Chunks.ChunksList.chunks">
            <summary>
             Includes all chunks, but IDAT is a single pseudo chunk without data
            </summary>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunksList.GetChunksKeys">
            <summary>
            Keys of processed (read or writen) chunks
            </summary>
            <returns>key:chunk id, val: number of occurrences</returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunksList.GetChunks">
            <summary>
            Returns a copy of the chunk list (but the chunks are not copied) 
            </summary>
            <remarks>This should not be used for general metadata handling
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunksList.AppendReadChunk(Edge.Tools.Images.Png.Chunks.PngChunk,System.Int32)">
            <summary>
            Adds chunk in next position. This is used only by the pngReader
            </summary>
            <param name="chunk"></param>
            <param name="chunkGroup"></param>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunksList.GetById(System.String)">
            <summary>
            All chunks with this ID
            </summary>
            <remarks>The GetBy... methods never include queued chunks</remarks>
            <param name="id"></param>
            <returns>List, empty if none</returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunksList.GetById(System.String,System.String)">
            <summary>
            Same as ID, but we an additional discriminator for textual keys
            </summary>
            <remarks>If innerid!=null and the chunk is PngChunkTextVar or PngChunkSPLT, it's filtered by that id</remarks>
            <param name="id"></param>
            <param name="innerid">Only used for text and SPLT chunks</param>
            <returns>List, empty if none</returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunksList.GetById1(System.String)">
            <summary>
            Returns only one chunk 
            </summary>
            <param name="id"></param>
            <returns>First chunk found, null if not found</returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunksList.GetById1(System.String,System.Boolean)">
            <summary>
            Returns only one chunk
            </summary>
            <param name="id"></param>
            <param name="failIfMultiple">true, and more than one found: exception</param>
            <returns>null if not found</returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunksList.GetById1(System.String,System.String,System.Boolean)">
            <summary>
            Sames as <c>GetById1(String id, bool failIfMultiple)</c> but allows an additional innerid
            </summary>
            <param name="id"></param>
            <param name="innerid"></param>
            <param name="failIfMultiple">true, and more than one found: exception</param>
            <returns>null if not found</returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunksList.GetEquivalent(Edge.Tools.Images.Png.Chunks.PngChunk)">
            <summary>
            Finds all chunks "equivalent" to this one
            </summary>
            <param name="chunk"></param>
            <returns>Empty if nothing found</returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunksList.ToString">
            <summary>
            Only the amount of chunks
            </summary>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunksList.ToStringFull">
            <summary>
            Detailed information, for debugging
            </summary>
            <returns></returns>
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.ChunksListForWrite">
             <summary>
             Chunks written or queued to be written 
             http://www.w3.org/TR/PNG/#table53
             </summary>
            
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunksListForWrite.GetQueuedById(System.String)">
            <summary>
            Same as <c>getById()</c>, but looking in the queued chunks
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunksListForWrite.GetQueuedById(System.String,System.String)">
            <summary>
            Same as <c>getById()</c>, but looking in the queued chunks
            </summary>
            <param name="id"></param>
            <param name="innerid"></param>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunksListForWrite.GetQueuedById1(System.String,System.String,System.Boolean)">
            <summary>
            Same as <c>getById()</c>, but looking in the queued chunks
            </summary>
            <param name="id"></param>
            <param name="innerid"></param>
            <param name="failIfMultiple"></param>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunksListForWrite.GetQueuedById1(System.String,System.Boolean)">
            <summary>
            Same as <c>getById1()</c>, but looking in the queued chunks
            </summary>
            <param name="id"></param>
            <param name="failIfMultiple"></param>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunksListForWrite.GetQueuedById1(System.String)">
            <summary>
            Same as getById1(), but looking in the queued chunks
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunksListForWrite.RemoveChunk(Edge.Tools.Images.Png.Chunks.PngChunk)">
             <summary>
            Remove Chunk: only from queued 
             </summary>
             <remarks>
             WARNING: this depends on chunk.Equals() implementation, which is straightforward for SingleChunks. For 
             MultipleChunks, it will normally check for reference equality!
             </remarks>
             <param name="c"></param>
             <returns></returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunksListForWrite.Queue(Edge.Tools.Images.Png.Chunks.PngChunk)">
            <summary>
            Adds chunk to queue
            </summary>
            <remarks>Does not check for duplicated or anything</remarks>
            <param name="chunk"></param>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunksListForWrite.shouldWrite(Edge.Tools.Images.Png.Chunks.PngChunk,System.Int32)">
             this should be called only for ancillary chunks and PLTE (groups 1 - 3 - 5)
            
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.ChunksListForWrite.GetQueuedChunks">
            <summary>
            chunks not yet writen - does not include IHDR, IDAT, END, perhaps yes PLTE
            </summary>
            <returns>THis is not a copy! Don't modify</returns>
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.PngChunk">
            <summary>
            Represents a instance of a PNG chunk
            </summary>
            <remarks>
            Concrete classes should extend <c>PngChunkSingle</c> or <c>PngChunkMultiple</c>
            
            Note that some methods/fields are type-specific (GetOrderingConstraint(), AllowsMultiple())
            some are 'almost' type-specific (Id,Crit,Pub,Safe; the exception is <c>PngUKNOWN</c>), 
            and some are instance-specific
            
            Ref: http://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html
            </remarks>
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.PngChunk.ChunkOrderingConstraint">
            <summary>
            Restrictions for chunk ordering, for ancillary chunks
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.Chunks.PngChunk.ChunkOrderingConstraint.NONE">
            <summary>
            No constraint, the chunk can go anywhere
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.Chunks.PngChunk.ChunkOrderingConstraint.BEFORE_PLTE_AND_IDAT">
            <summary>
            Before PLTE (palette) - and hence, also before IDAT
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.Chunks.PngChunk.ChunkOrderingConstraint.AFTER_PLTE_BEFORE_IDAT">
            <summary>
            After PLTE (palette), but before IDAT
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.Chunks.PngChunk.ChunkOrderingConstraint.BEFORE_IDAT">
            <summary>
            Before IDAT (before or after PLTE)
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.Chunks.PngChunk.ChunkOrderingConstraint.NA">
            <summary>
            Does not apply
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.Chunks.PngChunk.Crit">
            <summary>
            Standard basic properties, implicit in the Id
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.Chunks.PngChunk.Pub">
            <summary>
            Standard basic properties, implicit in the Id
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.Chunks.PngChunk.Safe">
            <summary>
            Standard basic properties, implicit in the Id
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.Chunks.PngChunk.Id">
            <summary>
            4 letters. The Id almost determines the concrete type (except for PngUKNOWN)
            </summary>
        </member>
        <member name="P:Edge.Tools.Images.Png.Chunks.PngChunk.Priority">
            <summary>
            For writing. Queued chunks with high priority will be written as soon as possible
            </summary>
        </member>
        <member name="P:Edge.Tools.Images.Png.Chunks.PngChunk.ChunkGroup">
            <summary>
            Chunk group where it was read or writen
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.Chunks.PngChunk.ImgInfo">
            <summary>
            Image basic info, mostly for some checks
            </summary>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngChunk.#ctor(System.String,Edge.Tools.Images.Png.ImageInfo)">
            <summary>
            Constructs an empty chunk
            </summary>
            <param name="id"></param>
            <param name="imgInfo"></param>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngChunk.FactoryRegister(System.String,System.Type)">
            <summary>
            Registers a Chunk ID in the factory, to instantiate a given type
            </summary>
            <remarks>
            This can be called by client code to register additional chunk types
            </remarks>
            <param name="chunkId"></param>
            <param name="type">should extend PngChunkSingle or PngChunkMultiple</param>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngChunk.FactoryFromId(System.String,Edge.Tools.Images.Png.ImageInfo)">
            <summary>
            Creates one new blank chunk of the corresponding type, according to factoryMap (PngChunkUNKNOWN if not known)
            </summary>
            <param name="cid">Chunk Id</param>
            <param name="info"></param>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngChunk.ToString">
            <summary>
            Basic info: Id, length, Type name
            </summary>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngChunk.CreateRawChunk">
            <summary>
            Serialization. Creates a Raw chunk, ready for write, from this chunk content
            </summary>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngChunk.ParseFromRaw(Edge.Tools.Images.Png.Chunks.ChunkRaw)">
            <summary>
            Deserialization. Given a Raw chunk, just rad, fills this chunk content
            </summary>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngChunk.CloneDataFromRead(Edge.Tools.Images.Png.Chunks.PngChunk)">
            <summary>
            Override to make a copy (normally deep) from other chunk
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngChunk.AllowsMultiple">
            <summary>
            This is implemented in PngChunkMultiple/PngChunSingle
            </summary>
            <returns>Allows more than one chunk of this type in a image</returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngChunk.GetOrderingConstraint">
            <summary>
            Get ordering constrain
            </summary>
            <returns></returns>
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.PngChunkBKGD">
            <summary>
            bKGD chunk, see http://www.w3.org/TR/PNG/#11bKGD
            </summary>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngChunkBKGD.SetGray(System.Int32)">
            <summary>
            Set gray value (0-255 if bitdept=8)
            </summary>
            <param name="gray"></param>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngChunkBKGD.GetGray">
            <summary>
            Gets gray value 
            </summary>
            <returns>gray value  (0-255 if bitdept=8)</returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngChunkBKGD.SetPaletteIndex(System.Int32)">
            <summary>
            Set pallette index - only for indexed
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngChunkBKGD.GetPaletteIndex">
            <summary>
            Get pallette index - only for indexed
            </summary>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngChunkBKGD.SetRGB(System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets rgb value, only for rgb images
            </summary>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngChunkBKGD.GetRGB">
            <summary>
            Gets rgb value, only for rgb images
            </summary>
            <returns>[r , g, b] array</returns>
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.PngChunkCHRM">
            <summary>
            cHRM chunk, see http://www.w3.org/TR/PNG/#11cHRM
            </summary>
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.PngChunkGAMA">
            <summary>
            gAMA chunk, see http://www.w3.org/TR/PNG/#11gAMA
            </summary>
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.PngChunkHIST">
            <summary>
            hIST chunk, see http://www.w3.org/TR/PNG/#11hIST
            Only for palette images
            </summary>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngChunkHIST.SetHist(System.Int32[])">
            <summary>
            should have same length as palette
            </summary>
            <param name="hist"></param>
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.PngChunkICCP">
            <summary>
            iCCP Chunk: see http://www.w3.org/TR/PNG/#11iCCP
            </summary>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngChunkICCP.SetProfileNameAndContent(System.String,System.String)">
            <summary>
            Sets profile name and profile
            </summary>
            <param name="name">profile name </param>
            <param name="profile">profile (latin1 string)</param>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngChunkICCP.SetProfileNameAndContent(System.String,System.Byte[])">
            <summary>
            Sets profile name and profile
            </summary>
            <param name="name">profile name </param>
            <param name="profile">profile (uncompressed)</param>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngChunkICCP.GetProfile">
            <summary>
            This uncompresses the string!
            </summary>
            <returns></returns>
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.PngChunkIDAT">
            <summary>
            IDAT chunk http://www.w3.org/TR/PNG/#11IDAT
            
            This object is dummy placeholder - We treat this chunk in a very different way than ancillary chnks
            </summary>
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.PngChunkIEND">
            <summary>
            IEND chunk  http://www.w3.org/TR/PNG/#11IEND
            </summary>
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.PngChunkIHDR">
            <summary>
            IHDR chunk: http://www.w3.org/TR/PNG/#11IHDR
            </summary>
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.PngChunkITXT">
            <summary>
            iTXt chunk:  http://www.w3.org/TR/PNG/#11iTXt
            One of the three text chunks
            </summary>
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.PngChunkMultiple">
            <summary>
            A Chunk type that allows duplicate in an image
            </summary>
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.PngChunkOFFS">
            <summary>
            oFFs chunk: http://www.libpng.org/pub/png/spec/register/pngext-1.3.0-pdg.html#C.oFFs
            </summary>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngChunkOFFS.GetUnits">
            <summary>
            0: pixel, 1:micrometer
            </summary>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngChunkOFFS.SetUnits(System.Int32)">
            <summary>
            0: pixel, 1:micrometer
            </summary>
            <param name="units"></param>
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.PngChunkPHYS">
            <summary>
            pHYs chunk: http://www.w3.org/TR/PNG/#11pHYs
            </summary>
        </member>
        <member name="P:Edge.Tools.Images.Png.Chunks.PngChunkPHYS.Units">
            <summary>
            0: unknown 1:metre
            </summary>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngChunkPHYS.GetAsDpi">
            <summary>
            returns -1 if not in meters, or not equal
            </summary>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngChunkPHYS.GetAsDpi2">
            <summary>
            returns -1 if the physicial unit is unknown
            </summary>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngChunkPHYS.SetAsDpi(System.Double)">
            <summary>
            same in both directions
            </summary>
            <param name="dpi"></param>
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.PngChunkPLTE">
            <summary>
            PLTE Palette chunk: this is the only optional critical chunk
            
            http://www.w3.org/TR/PNG/#11PLTE
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.Chunks.PngChunkPLTE.entries">
            <summary>
            
            </summary>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngChunkPLTE.SetNentries(System.Int32)">
            <summary>
            Also allocates array
            </summary>
            <param name="nentries">1-256</param>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngChunkPLTE.GetEntry(System.Int32)">
            <summary>
            as packed RGB8
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngChunkPLTE.GetEntryRgb(System.Int32,System.Int32[],System.Int32)">
            <summary>
            Gets n'th entry, filling 3 positions of given array, at given offset
            </summary>
            <param name="index"></param>
            <param name="rgb"></param>
            <param name="offset"></param>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngChunkPLTE.GetEntryRgb(System.Int32,System.Int32[])">
            <summary>
            shortcut: GetEntryRgb(index, int[] rgb, 0)
            </summary>
            <param name="n"></param>
            <param name="rgb"></param>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngChunkPLTE.MinBitDepth">
            <summary>
            minimum allowed bit depth, given palette size
            </summary>
            <returns>1-2-4-8</returns>
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.PngChunkSBIT">
            <summary>
            sBIT chunk: http://www.w3.org/TR/PNG/#11sBIT
            
            this chunk structure depends on the image type
            </summary>
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.PngChunkSingle">
            <summary>
            A Chunk type that does not allow duplicate in an image
            </summary>
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.PngChunkSPLT">
            <summary>
            sPLT chunk: http://www.w3.org/TR/PNG/#11sPLT
            </summary>
        </member>
        <member name="P:Edge.Tools.Images.Png.Chunks.PngChunkSPLT.PalName">
            <summary>
            Must be unique in image
            </summary>
        </member>
        <member name="P:Edge.Tools.Images.Png.Chunks.PngChunkSPLT.SampleDepth">
            <summary>
            8-16
            </summary>
        </member>
        <member name="P:Edge.Tools.Images.Png.Chunks.PngChunkSPLT.Palette">
            <summary>
            5 elements per entry
            </summary>
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.PngChunkSRGB">
            <summary>
            sRGB chunk: http://www.w3.org/TR/PNG/#11sRGB
            </summary>
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.PngChunkSTER">
            <summary>
            sTER chunk: http://www.libpng.org/pub/png/spec/register/pngext-1.3.0-pdg.html#C.sTER
            </summary>
        </member>
        <member name="P:Edge.Tools.Images.Png.Chunks.PngChunkSTER.Mode">
            <summary>
            0: cross-fuse layout 1: diverging-fuse layout
            </summary>
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.PngChunkTEXT">
            <summary>
            tEXt chunk: latin1 uncompressed text
            </summary>
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.PngChunkTextVar">
            <summary>
            general class for textual chunks
            </summary>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngChunkTextVar.GetKey">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.PngChunkTIME">
            <summary>
            tIME chunk: http://www.w3.org/TR/PNG/#11tIME
            </summary>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngChunkTIME.GetAsString">
            format YYYY/MM/DD HH:mm:SS 
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.PngChunkTRNS">
            <summary>
            tRNS chunk: http://www.w3.org/TR/PNG/#11tRNS
            </summary>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngChunkTRNS.SetPalletteAlpha(System.Int32[])">
            <summary>
            WARNING: non deep copy
            </summary>
            <param name="palAlpha"></param>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngChunkTRNS.setIndexEntryAsTransparent(System.Int32)">
            <summary>
            utiliy method : to use when only one pallete index is set as totally transparent
            </summary>
            <param name="palAlphaIndex"></param>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngChunkTRNS.GetPalletteAlpha">
            <summary>
            WARNING: non deep copy
            </summary>
            <returns></returns>
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.PngChunkUNKNOWN">
            <summary>
            Unknown (for our chunk factory) chunk type.
            </summary>
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.PngChunkZTXT">
            <summary>
            zTXt chunk: http://www.w3.org/TR/PNG/#11zTXt
            
            </summary>
        </member>
        <member name="T:Edge.Tools.Images.Png.Chunks.PngMetadata">
            <summary>Image Metadata, wrapper over a ChunksList</summary>
            <remarks>
            Additional image info, apart from the ImageInfo and the pixels themselves. 
            Includes Palette and ancillary chunks.
            This class provides a wrapper over the collection of chunks of a image (read or to write) and provides some high
            level methods to access them
            </remarks>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngMetadata.QueueChunk(Edge.Tools.Images.Png.Chunks.PngChunk,System.Boolean)">
            <summary>Queues the chunk at the writer</summary>
            <param name="chunk">Chunk, ready for write</param>
            <param name="lazyOverwrite">Ovewrite lazily equivalent chunks</param>
            <remarks>Warning: the overwriting applies to equivalent chunks, see <c>ChunkPredicateEquiv</c>
            and will only make sense for queued (not yet writen) chunks
            </remarks>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngMetadata.QueueChunk(Edge.Tools.Images.Png.Chunks.PngChunk)">
            <summary>Queues the chunk at the writer</summary>
            <param name="chunk">Chunk, ready for write</param>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngMetadata.GetDpi">
            <summary>
            Returns physical resolution, in DPI, in both coordinates
            </summary>
            <returns>[dpix,dpiy], -1 if not set or unknown dimensions</returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngMetadata.SetDpi(System.Double,System.Double)">
            <summary>
            Sets physical resolution, in DPI
            </summary>
            <remarks>This is a utility method that creates and enqueues a PHYS chunk</remarks>
            <param name="dpix">Resolution in x</param>
            <param name="dpiy">Resolution in y</param>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngMetadata.SetDpi(System.Double)">
            <summary>
            Sets physical resolution, in DPI, both value in x and y dimensions
            </summary>
            <remarks>This is a utility method that creates and enqueues a PHYS chunk</remarks>
            <param name="dpi">Resolution in dpi</param>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngMetadata.SetTimeNow(System.Int32)">
            <summary>
            Creates a TIME chunk,  <c>nsecs</c> in the past from now.
            </summary>
            <param name="nsecs">Seconds in the past. If negative, it's a future time</param>
            <returns>The created and queued chunk</returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngMetadata.SetTimeNow">
             <summary>
            Creates a TIME chunk with current time.
             </summary>
             <returns>The created and queued chunk</returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngMetadata.SetTimeYMDHMS(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a TIME chunk with given date and time
            </summary>
            <param name="year">Year</param>
            <param name="mon">Month (1-12)</param>
            <param name="day">Day of month (1-31)</param>
            <param name="hour">Hour (0-23)</param>
            <param name="min">Minute (0-59)</param>
            <param name="sec">Seconds (0-59)</param>
            <returns>The created and queued chunk</returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngMetadata.GetTime">
            <summary>
            Gets image timestamp, TIME chunk
            </summary>
            <returns>TIME chunk, null if not present</returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngMetadata.GetTimeAsString">
            <summary>
            Gets image timestamp, TIME chunk, as a String
            </summary>
            <returns>Formated TIME, empty string if not present</returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngMetadata.SetText(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Creates a text chunk and enqueues it
            </summary>
            <param name="key">Key. Short and ASCII string</param>
            <param name="val">Text.</param>
            <param name="useLatin1">Flag. If false, will use UTF-8 (iTXt)</param>
            <param name="compress">Flag. Uses zTXt chunk.</param>
            <returns>The created and enqueued chunk</returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngMetadata.SetText(System.String,System.String)">
            <summary>
            Creates a plain text chunk (tEXT) and enqueues it
            </summary>
            <param name="key">Key</param>
            <param name="val">Text</param>
            <returns>The created and enqueued chunk</returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngMetadata.GetTxtsForKey(System.String)">
            <summary>
            Retrieves all text chunks with a given key
            </summary>
            <param name="key">Key</param>
            <returns>Empty list if nothing found</returns>
            <remarks>Can mix tEXt zTXt and iTXt chunks</remarks>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngMetadata.GetTxtForKey(System.String)">
            <summary>
            Joins all strings for a given key
            </summary>
            <param name="key">Key</param>
            <returns>Concatenated (with newlines) if several found, empty string if none</returns>
            <remarks>You'd perhaps prefer GetTxtsForKey</remarks>
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngMetadata.GetTRNS">
            Returns the TRNS chunk, if present
            
            @return null if not present
        </member>
        <member name="M:Edge.Tools.Images.Png.Chunks.PngMetadata.CreateTRNSChunk">
            Creates a new empty TRNS chunk, queues it for write and return it to the caller, who should fill its entries
        </member>
        <member name="T:Edge.Tools.Images.Png.FileHelper">
             <summary>
             A few utility static methods to read and write files
             </summary>
            
        </member>
        <member name="M:Edge.Tools.Images.Png.FileHelper.CreatePngWriter(System.String,Edge.Tools.Images.Png.ImageInfo,System.Boolean)">
            <summary>
            Given a filename and a ImageInfo, produces a PngWriter object, ready for writing.</summary>
            <param name="fileName">Path of file</param>
            <param name="imgInfo">ImageInfo object</param>
            <param name="allowOverwrite">Flag: if false and file exists, a PngjOutputException is thrown</param>
            <returns>A PngWriter object, ready for writing</returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.FileHelper.CreatePngReader(System.String)">
            <summary>
            Given a filename, produces a PngReader object, ready for reading.
            </summary>
            <param name="fileName">Path of file</param>
            <returns>PngReader, ready for reading</returns>
        </member>
        <member name="T:Edge.Tools.Images.Png.FilterType">
            <summary>
            Internal PNG predictor filter, or a strategy to select it.
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.FilterType.FILTER_NONE">
            <summary>
            No filtering 
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.FilterType.FILTER_SUB">
            <summary>
            SUB filter: uses same row
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.FilterType.FILTER_UP">
            <summary>
             UP filter: uses previous row
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.FilterType.FILTER_AVERAGE">
             <summary>
            AVERAGE filter: uses neighbors
             </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.FilterType.FILTER_PAETH">
            <summary>
            PAETH predictor
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.FilterType.FILTER_DEFAULT">
            <summary>
            Default strategy: select one of the standard filters depending on global image parameters
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.FilterType.FILTER_AGGRESSIVE">
            <summary>
            Aggressive strategy: select dinamically the filters, trying every 8 rows
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.FilterType.FILTER_VERYAGGRESSIVE">
            <summary>
            Very aggressive and slow strategy: tries all filters for each row
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.FilterType.FILTER_CYCLIC">
            <summary>
            Uses all fiters, one for lines, in cyclic way. Only useful for testing.
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.FilterType.FILTER_UNKNOWN">
            <summary>
            Not specified, placeholder for unknown or NA filters. 
            </summary>
        </member>
        <member name="T:Edge.Tools.Images.Png.FilterWriteStrategy">
            <summary>
            Manages the writer strategy for selecting the internal png predictor filter
            </summary>
        </member>
        <member name="T:Edge.Tools.Images.Png.ImageInfo">
            <summary>
            Simple immutable wrapper for basic image info
            </summary>
            <remarks>
            Some parameters are clearly redundant
            The constructor requires an 'ortogonal' subset
            http://www.w3.org/TR/PNG/#11IHDR
            </remarks>
        </member>
        <member name="F:Edge.Tools.Images.Png.ImageInfo.Alpha">
            <summary>
            flag: has alpha channel
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.ImageInfo.BitDepth">
             <summary>
             Bits per sample (per channel) in the buffer. 
             </summary>
             <remarks>
             This is 8 or 16 for RGB/ARGB images. 
             For grayscale, it's 8 (or 1 2 4 ).
             For indexed images, number of bits per palette index (1 2 4 8).
            </remarks>
        </member>
        <member name="F:Edge.Tools.Images.Png.ImageInfo.BitspPixel">
            <summary>
            Bits used for each pixel in the buffer 
            </summary>
            <remarks>equals <c>channels * bitDepth</c>
            </remarks>
        </member>
        <member name="F:Edge.Tools.Images.Png.ImageInfo.BytesPerRow">
            <summary>
            Bytes per row, rounded up
            </summary>
            <remarks>equals <c>ceil(bitspp*cols/8)</c></remarks>
        </member>
        <member name="F:Edge.Tools.Images.Png.ImageInfo.BytesPixel">
            <summary>
            Bytes per pixel, rounded up
            </summary>
            <remarks>This is mainly for internal use (filter)</remarks>
        </member>
        <member name="F:Edge.Tools.Images.Png.ImageInfo.Channels">
             <summary>
             Number of channels, used in the buffer 
             </summary>
             <remarks>
             WARNING: This is 3-4 for rgb/rgba, but 1 for palette/gray !
            </remarks>
        </member>
        <member name="F:Edge.Tools.Images.Png.ImageInfo.Cols">
            <summary>
            Image width, in pixels
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.ImageInfo.Greyscale">
            <summary>
            flag: is grayscale (G/GA)
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.ImageInfo.Indexed">
            <summary>
            flag: has palette
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.ImageInfo.Packed">
            <summary>
            flag: less than one byte per sample (bit depth 1-2-4) 
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.ImageInfo.Rows">
            <summary>
            Image height, in pixels
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.ImageInfo.SamplesPerRow">
            <summary>
            Samples (scalar values) per row
            </summary>
            <remarks>
            Equals <c>cols * channels</c>
            </remarks>
        </member>
        <member name="F:Edge.Tools.Images.Png.ImageInfo.SamplesPerRowPacked">
            <summary>
            Number of values in our scanline, which might be packed.
            </summary>
            <remarks>
            Equals samplesPerRow if not packed. Elsewhere, it's lower
            For internal use, mostly.
            </remarks>
        </member>
        <member name="M:Edge.Tools.Images.Png.ImageInfo.#ctor(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Simple constructor: only for RGB/RGBA
            </summary>
        </member>
        <member name="M:Edge.Tools.Images.Png.ImageInfo.#ctor(System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            General Constructor
            </summary>
            <param name="cols">Width in pixels</param>
            <param name="rows">Height in pixels</param>
            <param name="bitdepth">Bits per sample per channel</param>
            <param name="alpha">Has alpha channel</param>
            <param name="grayscale">Is grayscale</param>
            <param name="palette">Has palette</param>
        </member>
        <member name="M:Edge.Tools.Images.Png.ImageInfo.ToString">
            <summary>
            General information, for debugging
            </summary>
            <returns>Summary</returns>
        </member>
        <member name="T:Edge.Tools.Images.Png.ImageLine">
             <summary>
             Lightweight wrapper for an image scanline, for read and write
             </summary>
             <remarks>It can be (usually it is) reused while iterating over the image lines
             See <c>scanline</c> field doc, to understand the format.
            </remarks>
        </member>
        <member name="P:Edge.Tools.Images.Png.ImageLine.ImgInfo">
            <summary>
            ImageInfo (readonly inmutable)
            </summary>
        </member>
        <member name="P:Edge.Tools.Images.Png.ImageLine.Scanline">
            <summary>
            Samples of an image line
            </summary>
            <remarks>
            
            The 'scanline' is an array of integers, corresponds to an image line (row)
            Except for 'packed' formats (gray/indexed with 1-2-4 bitdepth) each int is a
            "sample" (one for channel), (0-255 or 0-65535) in the respective PNG sequence
            sequence : (R G B R G B...) or (R G B A R G B A...) or (g g g ...) or ( i i i
            ) (palette index)
            
            For bitdepth 1/2/4 ,and if samplesUnpacked=false, each value is a PACKED byte! To get an unpacked copy,
            see <c>Pack()</c> and its inverse <c>Unpack()</c>
            
            To convert a indexed line to RGB balues, see ImageLineHelper.PalIdx2RGB()
            (cant do the reverse)
            </remarks>
        </member>
        <member name="P:Edge.Tools.Images.Png.ImageLine.ScanlineB">
            <summary>
            Same as Scanline, but with one byte per sample. Only one of Scanline and ScanlineB is valid - this depends
            on SampleType}
            </summary>
        </member>
        <member name="P:Edge.Tools.Images.Png.ImageLine.Rown">
            <summary>
            tracks the current row number (from 0 to rows-1)
            </summary>
        </member>
        <member name="P:Edge.Tools.Images.Png.ImageLine.ElementsPerRow">
            <summary>
            Hown many elements has the scanline array
            =imgInfo.samplePerRowPacked, if packed, imgInfo.samplePerRow elsewhere
            </summary>
        </member>
        <member name="P:Edge.Tools.Images.Png.ImageLine.maxSampleVal">
            <summary>
            Maximum sample value that this line admits: typically 255; less if bitdepth less than 8, 65535 if 16bits
            </summary>
        </member>
        <member name="P:Edge.Tools.Images.Png.ImageLine.SampleType">
            <summary>
            Determines if samples are stored in integers or in bytes
            </summary>
        </member>
        <member name="P:Edge.Tools.Images.Png.ImageLine.SamplesUnpacked">
            <summary>
            True: each scanline element is a sample.
            False: each scanline element has severals samples packed in a byte
            </summary>
        </member>
        <member name="P:Edge.Tools.Images.Png.ImageLine.FilterUsed">
            <summary>
            informational only ; filled by the reader
            </summary>
        </member>
        <member name="M:Edge.Tools.Images.Png.ImageLine.#ctor(Edge.Tools.Images.Png.ImageInfo,Edge.Tools.Images.Png.ImageLine.ESampleType,System.Boolean)">
            <summary>
            Constructs an ImageLine
            </summary>
            <param name="imgInfo">Inmutable copy of PNG ImageInfo</param>
            <param name="stype">Storage for samples:INT (default) or BYTE</param>
            <param name="unpackedMode">If true and bitdepth less than 8, samples are unpacked. This has no effect if biddepth 8 or 16</param>
        </member>
        <member name="M:Edge.Tools.Images.Png.ImageLine.packInplaceByte(Edge.Tools.Images.Png.ImageInfo,System.Byte[],System.Byte[],System.Boolean)">
            size original: samplesPerRow sizeFinal: samplesPerRowPacked (trailing elements are trash!) *
        </member>
        <member name="M:Edge.Tools.Images.Png.ImageLine.SetScanLine(System.Int32[])">
            <summary>
            Makes a deep copy
            </summary>
            <remarks>You should rarely use this</remarks>
            <param name="b"></param>
        </member>
        <member name="M:Edge.Tools.Images.Png.ImageLine.GetScanLineCopy(System.Int32[])">
            <summary>
            Makes a deep copy
            </summary>
            <remarks>You should rarely use this</remarks>
            <param name="b"></param>
        </member>
        <member name="T:Edge.Tools.Images.Png.ImageLineHelper">
             <summary>
             Bunch of utility static methods to process/analyze an image line. 
             
             Not essential at all, some methods are probably to be removed if future releases.
             
             TODO: document this better
             
             </summary>
            
        </member>
        <member name="M:Edge.Tools.Images.Png.ImageLineHelper.Palette2rgb(Edge.Tools.Images.Png.ImageLine,Edge.Tools.Images.Png.Chunks.PngChunkPLTE,Edge.Tools.Images.Png.Chunks.PngChunkTRNS,System.Int32[])">
            <summary>
            Given an indexed line with a palette, unpacks as a RGB array
            </summary>
            <param name="line">ImageLine as returned from PngReader</param>
            <param name="pal">Palette chunk</param>
            <param name="trns">TRNS chunk (optional)</param>
            <param name="buf">Preallocated array, optional</param>
            <returns>R G B (one byte per sample)</returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.ImageLineHelper.ClampDouble(System.Double)">
            [0,1)
        </member>
        <member name="T:Edge.Tools.Images.Png.ImageLines">
            <summary>
            Wraps a set of rows from a image, read in a single operation, stored in a int[][] or byte[][] matrix
            
            They can be a subset of the total rows, but in this case they are equispaced.
            
            See also ImageLine
            </summary>
        </member>
        <member name="M:Edge.Tools.Images.Png.ImageLines.ImageRowToMatrixRow(System.Int32)">
            <summary>
            Translates from image row number to matrix row.
            If you are not sure if this image row in included, use better ImageRowToMatrixRowStrict
            
            </summary>
            <param name="imrow">Row number in the original image (from 0) </param>
            <returns>Row number in the wrapped matrix. Undefined result if invalid</returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.ImageLines.ImageRowToMatrixRowStrict(System.Int32)">
            <summary>
            translates from image row number to matrix row
            </summary>
            <param name="imrow">Row number in the original image (from 0) </param>
            <returns>Row number in the wrapped matrix. Returns -1 if invalid</returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.ImageLines.MatrixRowToImageRow(System.Int32)">
            <summary>
            Translates from matrix row number to real image row number
            </summary>
            <param name="mrow"></param>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.ImageLines.GetImageLineAtMatrixRow(System.Int32)">
            <summary>
            Constructs and returns an ImageLine object backed by a matrix row.
            This is quite efficient, no deep copy.
            </summary>
            <param name="mrow">Row number inside the matrix</param>
            <returns></returns>
        </member>
        <member name="T:Edge.Tools.Images.Png.PngCsUtils">
             <summary>
             Utility functions for C# porting
             </summary>
            
        </member>
        <member name="M:Edge.Tools.Images.Png.PngDeinterlacer.setRow(System.Int32)">
            this refers to the row currRowSubimg 
        </member>
        <member name="M:Edge.Tools.Images.Png.PngDeinterlacer.isAtLastRow">
            Is current row the last row for the lass pass??
        </member>
        <member name="M:Edge.Tools.Images.Png.PngDeinterlacer.getCurrRowSubimg">
            current row number inside the "sub image"
        </member>
        <member name="M:Edge.Tools.Images.Png.PngDeinterlacer.getCurrRowReal">
            current row number inside the "real image"
        </member>
        <member name="M:Edge.Tools.Images.Png.PngDeinterlacer.getPass">
            current pass number (1-7)
        </member>
        <member name="M:Edge.Tools.Images.Png.PngDeinterlacer.getRows">
             How many rows has the current pass?
            
        </member>
        <member name="M:Edge.Tools.Images.Png.PngDeinterlacer.getCols">
            How many columns (pixels) are there in the current row
        </member>
        <member name="T:Edge.Tools.Images.Png.PngHelperInternal">
            <summary>
            Some utility static methods for internal use.
            </summary>
        </member>
        <member name="M:Edge.Tools.Images.Png.PngHelperInternal.GetCRC">
             <summary>
             thread-singleton crc engine 
             </summary>
            
        </member>
        <member name="M:Edge.Tools.Images.Png.PngHelperInternal.ReadInt2(System.IO.Stream)">
             <summary>
             -1 si eof
             </summary>
            
        </member>
        <member name="M:Edge.Tools.Images.Png.PngHelperInternal.ReadInt4(System.IO.Stream)">
             <summary>
             -1 si eof
             </summary>
            
        </member>
        <member name="M:Edge.Tools.Images.Png.PngHelperInternal.ReadBytes(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
             <summary>
             guaranteed to read exactly len bytes. throws error if it cant
             </summary>
            
        </member>
        <member name="T:Edge.Tools.Images.Png.PngIDatChunkInputStream">
            <summary>
            Reads IDAT chunks
            </summary>
        </member>
        <member name="M:Edge.Tools.Images.Png.PngIDatChunkInputStream.#ctor(System.IO.Stream,System.Int32,System.Int64)">
             <summary>
             Constructor must be called just after reading length and id of first IDAT
             chunk
             </summary>
            
        </member>
        <member name="M:Edge.Tools.Images.Png.PngIDatChunkInputStream.Close">
             <summary>
             does NOT close the associated stream!
             </summary>
            
        </member>
        <member name="M:Edge.Tools.Images.Png.PngIDatChunkInputStream.ForceChunkEnd">
             <summary>
             sometimes last row read does not fully consumes the chunk here we read the
             reamaing dummy bytes
             </summary>
            
        </member>
        <member name="M:Edge.Tools.Images.Png.PngIDatChunkInputStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
             This can return less than len, but never 0 Returns -1 nothing more to read, -2 if "pseudo file" 
             ended prematurely. That is our error.
             </summary>
            
        </member>
        <member name="M:Edge.Tools.Images.Png.PngIDatChunkInputStream.DisableCrcCheck">
            <summary>
            Disables CRC checking. This can make reading faster
            </summary>
        </member>
        <member name="T:Edge.Tools.Images.Png.PngIDatChunkOutputStream">
             <summary>
             outputs the stream for IDAT chunk , fragmented at fixed size (32k default).
             </summary>
            
        </member>
        <member name="T:Edge.Tools.Images.Png.PngjBadCrcException">
            <summary>
            Exception for CRC check
            </summary>
        </member>
        <member name="T:Edge.Tools.Images.Png.PngjException">
            <summary>
            Gral exception class for PNGCS library
            </summary>
        </member>
        <member name="T:Edge.Tools.Images.Png.PngjExceptionInternal">
            <summary>
            Exception for internal problems
            </summary>
        </member>
        <member name="T:Edge.Tools.Images.Png.PngjInputException">
            <summary>
            Exception associated with input (reading) operations
            </summary>
        </member>
        <member name="T:Edge.Tools.Images.Png.PngjOutputException">
            <summary>
            Exception associated with input (reading) operations
            </summary>
        </member>
        <member name="T:Edge.Tools.Images.Png.PngjUnsupportedException">
            <summary>
            Exception for unsupported operation or feature
            </summary>
        </member>
        <member name="T:Edge.Tools.Images.Png.PngReader">
             <summary>
             Reads a PNG image, line by line
             </summary>
             <remarks>
             The typical reading sequence is as follows:
             
             1. At construction time, the header and IHDR chunk are read (basic image info)
             
             2  (Optional) you can set some global options: UnpackedMode CrcCheckDisabled
             
             3. (Optional) If you call GetMetadata() or or GetChunksLisk() before reading the pixels, the chunks before IDAT are automatically loaded and available
             
             4a. The rows are read, one by one, with the <tt>ReadRowXXX</tt> methods: (ReadRowInt() , ReadRowByte(), etc)
             in order, from 0 to nrows-1 (you can skip or repeat rows, but not go backwards)
             
             4b. Alternatively, you can read all rows, or a subset, in a single call: see ReadRowsInt(), ReadRowsByte()
             In general this consumes more memory, but for interlaced images this is equally efficient, and more so if reading a small subset of rows.
            
             5. Read of the last row automatically loads the trailing chunks, and ends the reader.
             
             6. End() forcibly finishes/aborts the reading and closes the stream
            
             </remarks>
        </member>
        <member name="P:Edge.Tools.Images.Png.PngReader.ImgInfo">
            <summary>
            Basic image info, inmutable
            </summary>
        </member>
        <member name="P:Edge.Tools.Images.Png.PngReader.ChunkLoadBehaviour">
            <summary>
            Strategy for chunk loading. Default: LOAD_CHUNK_ALWAYS
            </summary>
        </member>
        <member name="P:Edge.Tools.Images.Png.PngReader.ShouldCloseStream">
            <summary>
            Should close the underlying Input Stream when ends?
            </summary>
        </member>
        <member name="P:Edge.Tools.Images.Png.PngReader.MaxBytesMetadata">
            <summary>
            Maximum amount of bytes from ancillary chunks to load in memory 
            </summary>
            <remarks>
             Default: 5MB. 0: unlimited. If exceeded, chunks will be skipped
            </remarks>
        </member>
        <member name="P:Edge.Tools.Images.Png.PngReader.MaxTotalBytesRead">
            <summary>
            Maximum total bytes to read from stream 
            </summary>
            <remarks>
             Default: 200MB. 0: Unlimited. If exceeded, an exception will be thrown
            </remarks>
        </member>
        <member name="P:Edge.Tools.Images.Png.PngReader.SkipChunkMaxSize">
            <summary>
            Maximum ancillary chunk size
            </summary>
            <remarks>
             Default: 2MB, 0: unlimited. Chunks exceeding this size will be skipped (nor even CRC checked)
            </remarks>
        </member>
        <member name="P:Edge.Tools.Images.Png.PngReader.SkipChunkIds">
            <summary>
            Ancillary chunks to skip
            </summary>
            <remarks>
             Default: { "fdAT" }. chunks with these ids will be skipped (nor even CRC checked)
            </remarks>
        </member>
        <member name="P:Edge.Tools.Images.Png.PngReader.CurrentChunkGroup">
            <summary>
            number of chunk group (0-6) last read, or currently reading
            </summary>
            <remarks>see ChunksList.CHUNK_GROUP_NNN</remarks>
        </member>
        <member name="F:Edge.Tools.Images.Png.PngReader.filename">
            <summary>
            filename, or description - merely informative, can be empty
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.PngReader.imgLine">
            <summary>
            buffer: last read line
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.PngReader.rowb">
            <summary>
            raw current row, as array of bytes,counting from 1 (index 0 is reserved for filter type)
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.PngReader.rowbfilter">
            <summary>
            raw current row, after unfiltered
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.PngReader.rowbprev">
            <summary>
            previuos raw row
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.PngReader.rowNum">
            <summary>
            last read row number
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.PngReader.chunksList">
            <summary>
            Read chunks
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.PngReader.metadata">
            <summary>
            A high level wrapper of a ChunksList : list of read chunks
            </summary>
        </member>
        <member name="M:Edge.Tools.Images.Png.PngReader.#ctor(System.IO.Stream)">
            <summary>
            Constructs a PngReader from a Stream, with no filename information
            </summary>
            <param name="inputStream"></param>
        </member>
        <member name="M:Edge.Tools.Images.Png.PngReader.#ctor(System.IO.Stream,System.String)">
            <summary>
            Constructs a PNGReader objet from a opened Stream
            </summary>
            <remarks>The constructor reads the signature and first chunk (IDHR)<seealso cref="M:Edge.Tools.Images.Png.FileHelper.CreatePngReader(System.String)"/>
            </remarks>
            
            <param name="inputStream"></param>
            <param name="filename">Optional, can be the filename or a description.</param>
        </member>
        <member name="M:Edge.Tools.Images.Png.PngReader.ReadLastAndClose">
            <summary>
            Internally called after having read the last line. 
            It reads extra chunks after IDAT, if present.
            </summary>
        </member>
        <member name="M:Edge.Tools.Images.Png.PngReader.ReadFirstChunks">
             <summary>
             Reads chunks before first IDAT. Position before: after IDHR (crc included)
             Position after: just after the first IDAT chunk id Returns length of first
             IDAT chunk , -1 if not found
             </summary>
            
        </member>
        <member name="M:Edge.Tools.Images.Png.PngReader.ReadLastChunks">
             <summary>
             Reads (and processes ... up to a point) chunks after last IDAT.
             </summary>
            
        </member>
        <member name="M:Edge.Tools.Images.Png.PngReader.ReadChunk(System.Byte[],System.Int32,System.Boolean)">
            <summary>
            Reads chunkd from input stream, adds to ChunksList, and returns it.
            If it's skipped, a PngChunkSkipped object is created
            </summary>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.PngReader.logWarn(System.String)">
            <summary>
            Logs/prints a warning.
            </summary>
            <remarks>
            The default behaviour is print to stderr, but it can be overriden.
            This happens rarely - most errors are fatal.
            </remarks>
            <param name="warn"></param>
        </member>
        <member name="M:Edge.Tools.Images.Png.PngReader.GetChunksList">
            <summary>
            Returns the ancillary chunks available
            </summary>
            <remarks>
            If the rows have not yet still been read, this includes
            only the chunks placed before the pixels (IDAT)
            </remarks>
            <returns>ChunksList</returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.PngReader.GetMetadata">
            <summary>
            Returns the ancillary chunks available
            </summary>
            <remarks>
            see GetChunksList
            </remarks>
            <returns>PngMetadata</returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.PngReader.ReadRow(System.Int32)">
             <summary>
             reads the row using ImageLine as buffer
             </summary>
            <param name="nrow">row number - just as a check</param>
             <returns>the ImageLine that also is available inside this object</returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.PngReader.ReadRowByte(System.Byte*,System.Int32)">
            <summary>
            Super fast version, doesn't check any previous reading operations
            </summary>
            <param name="buffer"></param>
            <param name="nrow"></param>
        </member>
        <member name="M:Edge.Tools.Images.Png.PngReader.GetRow(System.Int32)">
            <summary>
            
            </summary>
            <param name="nrow"></param>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.PngReader.End">
            <summary>
            Normally this does nothing, but it can be used to force a premature closing
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Edge.Tools.Images.Png.PngReader.IsUnpackedMode">
            @see PngReader#setUnpackedMode(boolean)
        </member>
        <member name="T:Edge.Tools.Images.Png.PngReader2">
             <summary>
             Reads a PNG image, line by line
             </summary>
             <remarks>
             The typical reading sequence is as follows:
             
             1. At construction time, the header and IHDR chunk are read (basic image info)
             
             2  (Optional) you can set some global options: UnpackedMode CrcCheckDisabled
             
             3. (Optional) If you call GetMetadata() or or GetChunksLisk() before reading the pixels, the chunks before IDAT are automatically loaded and available
             
             4a. The rows are read, one by one, with the <tt>ReadRowXXX</tt> methods: (ReadRowInt() , ReadRowByte(), etc)
             in order, from 0 to nrows-1 (you can skip or repeat rows, but not go backwards)
             
             4b. Alternatively, you can read all rows, or a subset, in a single call: see ReadRowsInt(), ReadRowsByte()
             In general this consumes more memory, but for interlaced images this is equally efficient, and more so if reading a small subset of rows.
            
             5. Read of the last row automatically loads the trailing chunks, and ends the reader.
             
             6. End() forcibly finishes/aborts the reading and closes the stream
            
             </remarks>
        </member>
        <member name="F:Edge.Tools.Images.Png.PngReader2.MaxTotalBytesRead">
            <summary>
            Maximum total bytes to read from stream 
            </summary>
            <remarks>
             Default: 50MB. 0: Unlimited. If exceeded, an exception will be thrown
            </remarks>
        </member>
        <member name="F:Edge.Tools.Images.Png.PngReader2.LinesRead">
            <summary>
            Lines that have been read previously.
            </summary>
        </member>
        <member name="P:Edge.Tools.Images.Png.PngReader2.ImgInfo">
            <summary>
            Basic image info, inmutable
            </summary>
        </member>
        <member name="P:Edge.Tools.Images.Png.PngReader2.ChunkLoadBehaviour">
            <summary>
            Strategy for chunk loading. Default: LOAD_CHUNK_ALWAYS
            </summary>
        </member>
        <member name="P:Edge.Tools.Images.Png.PngReader2.ShouldCloseStream">
            <summary>
            Should close the underlying Input Stream when ends?
            </summary>
        </member>
        <member name="P:Edge.Tools.Images.Png.PngReader2.MaxBytesMetadata">
            <summary>
            Maximum amount of bytes from ancillary chunks to load in memory 
            </summary>
            <remarks>
             Default: 5MB. 0: unlimited. If exceeded, chunks will be skipped
            </remarks>
        </member>
        <member name="P:Edge.Tools.Images.Png.PngReader2.SkipChunkMaxSize">
            <summary>
            Maximum ancillary chunk size
            </summary>
            <remarks>
             Default: 2MB, 0: unlimited. Chunks exceeding this size will be skipped (nor even CRC checked)
            </remarks>
        </member>
        <member name="P:Edge.Tools.Images.Png.PngReader2.SkipChunkIds">
            <summary>
            Ancillary chunks to skip
            </summary>
            <remarks>
             Default: { "fdAT" }. chunks with these ids will be skipped (nor even CRC checked)
            </remarks>
        </member>
        <member name="P:Edge.Tools.Images.Png.PngReader2.CurrentChunkGroup">
            <summary>
            number of chunk group (0-6) last read, or currently reading
            </summary>
            <remarks>see ChunksList.CHUNK_GROUP_NNN</remarks>
        </member>
        <member name="F:Edge.Tools.Images.Png.PngReader2.filename">
            <summary>
            filename, or description - merely informative, can be empty
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.PngReader2.imgLine">
            <summary>
            buffer: last read line
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.PngReader2.rowbfilter">
            <summary>
            raw current row, after unfiltered
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.PngReader2.rowbRaw">
            <summary>
            raw current row, as array of bytes,counting from 1 (index 0 is reserved for filter type)
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.PngReader2.rowbRawPrev">
            <summary>
            previuos raw row
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.PngReader2.rowNum">
            <summary>
            last read row number
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.PngReader2.chunksList">
            <summary>
            Read chunks
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.PngReader2.metadata">
            <summary>
            A high level wrapper of a ChunksList : list of read chunks
            </summary>
        </member>
        <member name="M:Edge.Tools.Images.Png.PngReader2.#ctor(System.IO.Stream)">
            <summary>
            Constructs a PngReader from a Stream, with no filename information
            </summary>
            <param name="inputStream"></param>
        </member>
        <member name="M:Edge.Tools.Images.Png.PngReader2.#ctor(System.IO.Stream,System.String)">
            <summary>
            Constructs a PNGReader objet from a opened Stream
            </summary>
            <remarks>The constructor reads the signature and first chunk (IDHR)<seealso cref="M:Edge.Tools.Images.Png.FileHelper.CreatePngReader(System.String)"/>
            </remarks>
            
            <param name="inputStream"></param>
            <param name="filename">Optional, can be the filename or a description.</param>
        </member>
        <member name="M:Edge.Tools.Images.Png.PngReader2.ReadLastAndClose">
            <summary>
            Internally called after having read the last line. 
            It reads extra chunks after IDAT, if present.
            </summary>
        </member>
        <member name="M:Edge.Tools.Images.Png.PngReader2.ReadFirstChunks">
             <summary>
             Reads chunks before first IDAT. Position before: after IDHR (crc included)
             Position after: just after the first IDAT chunk id Returns length of first
             IDAT chunk , -1 if not found
             </summary>
            
        </member>
        <member name="M:Edge.Tools.Images.Png.PngReader2.ReadLastChunks">
             <summary>
             Reads (and processes ... up to a point) chunks after last IDAT.
             </summary>
            
        </member>
        <member name="M:Edge.Tools.Images.Png.PngReader2.ReadChunk(System.Byte[],System.Int32,System.Boolean)">
            <summary>
            Reads chunkd from input stream, adds to ChunksList, and returns it.
            If it's skipped, a PngChunkSkipped object is created
            </summary>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.PngReader2.logWarn(System.String)">
            <summary>
            Logs/prints a warning.
            </summary>
            <remarks>
            The default behaviour is print to stderr, but it can be overriden.
            This happens rarely - most errors are fatal.
            </remarks>
            <param name="warn"></param>
        </member>
        <member name="M:Edge.Tools.Images.Png.PngReader2.GetChunksList">
            <summary>
            Returns the ancillary chunks available
            </summary>
            <remarks>
            If the rows have not yet still been read, this includes
            only the chunks placed before the pixels (IDAT)
            </remarks>
            <returns>ChunksList</returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.PngReader2.GetMetadata">
            <summary>
            Returns the ancillary chunks available
            </summary>
            <remarks>
            see GetChunksList
            </remarks>
            <returns>PngMetadata</returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.PngReader2.ReadRowByte(System.Byte*,System.Int32)">
            <summary>
            Super fast version, doesn't check any previous reading operations
            </summary>
            <param name="buffer"></param>
            <param name="nrow"></param>
        </member>
        <member name="M:Edge.Tools.Images.Png.PngReader2.End">
            <summary>
            Normally this does nothing, but it can be used to force a premature closing
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Edge.Tools.Images.Png.PngReader2.IsUnpackedMode">
            @see PngReader#setUnpackedMode(boolean)
        </member>
        <member name="T:Edge.Tools.Images.Png.PngWriter">
            <summary>
             Writes a PNG image, line by line.
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.PngWriter.ImgInfo">
            <summary>
            Basic image info, inmutable
            </summary>
        </member>
        <member name="P:Edge.Tools.Images.Png.PngWriter.CompressionStrategy">
            Deflate algortithm compression strategy
        </member>
        <member name="P:Edge.Tools.Images.Png.PngWriter.CompLevel">
            <summary>
            zip compression level (0 - 9)
            </summary>
            <remarks>
            default:6
            
            9 is the maximum compression
            </remarks>
        </member>
        <member name="P:Edge.Tools.Images.Png.PngWriter.ShouldCloseStream">
            <summary>
            true: closes stream after ending write
            </summary>
        </member>
        <member name="P:Edge.Tools.Images.Png.PngWriter.IdatMaxSize">
            <summary>
            Maximum size of IDAT chunks
            </summary>
            <remarks>
            0=use default (PngIDatChunkOutputStream 32768)
            </remarks>
        </member>
        <member name="P:Edge.Tools.Images.Png.PngWriter.CurrentChunkGroup">
            <summary>
            number of chunk group (0-6) last writen, or currently writing
            </summary>
            <remarks>see ChunksList.CHUNK_GROUP_NNN</remarks>
        </member>
        <member name="F:Edge.Tools.Images.Png.PngWriter.filename">
            <summary>
            filename, or description - merely informative, can be empty
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.PngWriter.rowb">
            <summary>
            raw current row, as array of bytes,counting from 1 (index 0 is reserved for filter type)
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.PngWriter.rowbfilter">
            <summary>
            raw current row, after filtered
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.PngWriter.rowbprev">
            <summary>
            previuos raw row
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.PngWriter.chunksList">
            <summary>
            written/queued chunks
            </summary>
        </member>
        <member name="F:Edge.Tools.Images.Png.PngWriter.metadata">
            <summary>
            A high level wrapper of a ChunksList : list of written/queued chunks
            </summary>
        </member>
        <member name="M:Edge.Tools.Images.Png.PngWriter.#ctor(System.IO.Stream,Edge.Tools.Images.Png.ImageInfo)">
            <summary>
            Constructs a PngWriter from a outputStream, with no filename information
            </summary>
            <param name="outputStream"></param>
            <param name="imgInfo"></param>
        </member>
        <member name="M:Edge.Tools.Images.Png.PngWriter.#ctor(System.IO.Stream,Edge.Tools.Images.Png.ImageInfo,System.String)">
            <summary>
            Constructs a PngWriter from a outputStream, with optional filename or description
            </summary>
            <remarks>
            After construction nothing is writen yet. You still can set some
            parameters (compression, filters) and queue chunks before start writing the pixels.
            
            See also <c>FileHelper.createPngWriter()</c>
            </remarks>
            <param name="outputStream">Opened stream for binary writing</param>
            <param name="imgInfo">Basic image parameters</param>
            <param name="filename">Optional, can be the filename or a description.</param>
        </member>
        <member name="M:Edge.Tools.Images.Png.PngWriter.init">
            <summary>
            init: is called automatically before writing the first row
            </summary>
        </member>
        <member name="M:Edge.Tools.Images.Png.PngWriter.WriteSignatureAndIHDR">
             <summary>
             Write id signature and also "IHDR" chunk
             </summary>
            
        </member>
        <member name="M:Edge.Tools.Images.Png.PngWriter.CopyChunks(Edge.Tools.Images.Png.PngReader,System.Int32,System.Boolean)">
             <summary>
             copy chunks from reader - copy_mask : see ChunksToWrite.COPY_XXX
             If we are after idat, only considers those chunks after IDAT in PngReader
             TODO: this should be more customizable
             </summary>
            
        </member>
        <member name="M:Edge.Tools.Images.Png.PngWriter.ComputeCompressionRatio">
            <summary>
            Computes compressed size/raw size, approximate
            </summary>
            <remarks>Actually: compressed size = total size of IDAT data , raw size = uncompressed pixel bytes = rows * (bytesPerRow + 1)
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.PngWriter.End">
             <summary>
             Finalizes the image creation and closes the file stream. </summary>
               <remarks>
               This MUST be called after writing the lines.
               </remarks>      
            
        </member>
        <member name="M:Edge.Tools.Images.Png.PngWriter.GetFilename">
            <summary>
             Filename or description, from the optional constructor argument.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.PngWriter.WriteRow(Edge.Tools.Images.Png.ImageLine,System.Int32)">
             <summary>
             this uses the row number from the imageline!
             </summary>
            
        </member>
        <member name="M:Edge.Tools.Images.Png.PngWriter.WriteRowInt(System.Int32[],System.Int32)">
            <summary>
            Writes a full image row.
            </summary>
            <remarks>
            This must be called sequentially from n=0 to
            n=rows-1 One integer per sample , in the natural order: R G B R G B ... (or
            R G B A R G B A... if has alpha) The values should be between 0 and 255 for
            8 bitspc images, and between 0- 65535 form 16 bitspc images (this applies
            also to the alpha channel if present) The array can be reused.
            </remarks>
            <param name="newrow">Array of pixel values</param>
            <param name="rown">Number of row, from 0 (top) to rows-1 (bottom)</param>
        </member>
        <member name="M:Edge.Tools.Images.Png.PngWriter.WriteRowsInt(System.Int32[][])">
            Writes all the pixels, calling writeRowInt() for each image row
        </member>
        <member name="M:Edge.Tools.Images.Png.PngWriter.WriteRowsByte(System.Byte[][])">
            Writes all the pixels, calling writeRowByte() for each image row
        </member>
        <member name="M:Edge.Tools.Images.Png.PngWriter.SetFilterType(Edge.Tools.Images.Png.FilterType)">
            <summary>
            Sets internal prediction filter type, or strategy to choose it.
            </summary>
            <remarks>
            This must be called just after constructor, before starting writing.
            
            Recommended values: DEFAULT (default) or AGGRESIVE
            </remarks>
            <param name="filterType">One of the five prediction types or strategy to choose it</param>
        </member>
        <member name="T:Edge.Tools.Images.Png.ProgressiveOutputStream">
             <summary>
             stream that outputs to memory and allows to flush fragments every 'size'
             bytes to some other destination
             </summary>
            
        </member>
        <member name="M:Edge.Tools.Images.Png.ProgressiveOutputStream.CheckFlushBuffer(System.Boolean)">
             <summary>
             if it's time to flush data (or if forced==true) calls abstract method
             flushBuffer() and cleans those bytes from own buffer
             </summary>
            
        </member>
        <member name="M:Edge.Tools.Images.Png.Zlib.AZlibInputStream.getImplementationId">
            <summary>
            mainly for debugging
            </summary>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Images.Png.Zlib.AZlibOutputStream.getImplementationId">
            <summary>
            mainly for debugging
            </summary>
            <returns></returns>
        </member>
        <member name="T:Edge.Tools.Images.Png.Zlib.ZlibInputStreamMs">
            <summary>
            Zip input (deflater) based on Ms DeflateStream (.net 4.5)
            </summary>
        </member>
        <member name="F:Edge.Tools.Maths.Doubles.Sqrt2">
            <summary>
              Square root of 2
            </summary>
        </member>
        <member name="F:Edge.Tools.Maths.Floats.Sqrt2">
            <summary>
              Square root of 2
            </summary>
        </member>
        <member name="F:Edge.Tools.Maths.Floats.E">
            <summary>
            Represents the mathematical constant e(2.71828175).
            </summary>
        </member>
        <member name="F:Edge.Tools.Maths.Floats.Log10E">
            <summary>
            Represents the log base ten of e(0.4342945).
            </summary>
        </member>
        <member name="F:Edge.Tools.Maths.Floats.Log2E">
            <summary>
            Represents the log base two of e(1.442695).
            </summary>
        </member>
        <member name="F:Edge.Tools.Maths.Primes.Items">
            <summary>
            Contains 1000 first prime numbers
            </summary>
        </member>
        <member name="T:Edge.Tools.Random.FastRandom">
            <summary>
            A fast random number generator for .NET
            Colin Green, January 2005
            
            September 4th 2005
             Added NextBytesUnsafe() - commented out by default.
             Fixed bug in Reinitialise() - y,z and w variables were not being reset.
            
            Key points:
             1) Based on a simple and fast xor-shift pseudo random number generator (RNG) specified in: 
             Marsaglia, George. (2003). Xorshift RNGs.
             http://www.jstatsoft.org/v08/i14/xorshift.pdf
             
             This particular implementation of xorshift has a period of 2^128-1. See the above paper to see
             how this can be easily extened if you need a longer period. At the time of writing I could find no 
             information on the period of System.Random for comparison.
            
             2) Faster than System.Random. Up to 8x faster, depending on which methods are called.
            
             3) Direct replacement for System.Random. This class implements all of the methods that System.Random 
             does plus some additional methods. The like named methods are functionally equivalent.
             
             4) Allows fast re-initialisation with a seed, unlike System.Random which accepts a seed at construction
             time which then executes a relatively expensive initialisation routine. This provides a vast speed improvement
             if you need to reset the pseudo-random number sequence many times, e.g. if you want to re-generate the same
             sequence many times. An alternative might be to cache random numbers in an array, but that approach is limited
             by memory capacity and the fact that you may also want a large number of different sequences cached. Each sequence
             can each be represented by a single seed value (int) when using FastRandom.
             
             Notes.
             A further performance improvement can be obtained by declaring local variables as static, thus avoiding 
             re-allocation of variables on each call. However care should be taken if multiple instances of
             FastRandom are in use or if being used in a multi-threaded environment.
            
            </summary>
        </member>
        <member name="M:Edge.Tools.Random.FastRandom.Reinitialise(System.Int32)">
            <summary>
            Reinitialises using an int value as a seed.
            </summary>
            <param name="seed"></param>
        </member>
        <member name="M:Edge.Tools.Random.FastRandom.#ctor">
            <summary>
            Initialises a new instance using time dependent seed.
            </summary>
        </member>
        <member name="M:Edge.Tools.Random.FastRandom.#ctor(System.Int32)">
            <summary>
            Initialises a new instance using an int value as seed.
            This constructor signature is provided to maintain compatibility with
            System.Random
            </summary>
        </member>
        <member name="M:Edge.Tools.Random.FastRandom.Next">
            <summary>
            Generates a random int over the range 0 to int.MaxValue-1.
            MaxValue is not generated in order to remain functionally equivalent to System.Random.Next().
            This does slightly eat into some of the performance gain over System.Random, but not much.
            For better performance see:
            
            Call NextInt() for an int over the range 0 to int.MaxValue.
            
            Call NextUInt() and cast the result to an int to generate an int over the full Int32 value range
            including negative values. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Random.FastRandom.Next(System.Int32)">
            <summary>
            Generates a random int over the range 0 to upperBound-1, and not including upperBound.
            </summary>
            <param name="upperBound"></param>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Random.FastRandom.Next(System.Int32,System.Int32)">
            <summary>
            Generates a random int over the range lowerBound to upperBound-1, and not including upperBound.
            upperBound must be >= lowerBound. lowerBound may be negative.
            </summary>
            <param name="lowerBound"></param>
            <param name="upperBound"></param>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Random.FastRandom.NextDouble">
            <summary>
            Generates a random double. Values returned are from 0.0 up to but not including 1.0.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Random.FastRandom.NextBytes(System.Byte[])">
            <summary>
            Fills the provided byte array with random bytes.
            This method is functionally equivalent to System.Random.NextBytes(). 
            </summary>
            <param name="buffer"></param>
        </member>
        <member name="M:Edge.Tools.Random.FastRandom.NextUInt">
            <summary>
            Generates a uint. Values returned are over the full range of a uint, 
            uint.MinValue to uint.MaxValue, inclusive.
            
            This is the fastest method for generating a single random number because the underlying
            random number generator algorithm generates 32 random bits that can be cast directly to 
            a uint.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Random.FastRandom.NextInt">
            <summary>
            Generates a random int over the range 0 to int.MaxValue, inclusive. 
            This method differs from Next() only in that the range is 0 to int.MaxValue
            and not 0 to int.MaxValue-1.
            
            The slight difference in range means this method is slightly faster than Next()
            but is not functionally equivalent to System.Random.Next().
            </summary>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Random.FastRandom.NextBool">
            <summary>
            Generates a single random bit.
            This method's performance is improved by generating 32 bits in one operation and storing them
            ready for future calls.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Random.FastRandom.NextSignedSin">
            <summary>
                Returns the next random signed float using sin spread(-1 - 1).
            </summary>
        </member>
        <member name="M:Edge.Tools.Random.FastRandom.NextSignedReverseSin">
            <summary>
                Returns the next random signed float using reverse sin spread(-1 - 1).
                Spread is strong in the edges and weak in the middle (0 - range).
            </summary>
        </member>
        <member name="M:Edge.Tools.Random.IRandom.NextDouble">
            <summary>
            Returns the next random double. (0-1)
            </summary>
        </member>
        <member name="M:Edge.Tools.Random.IRandom.NextFloat">
            <summary>
            Returns the next random float. (0-1)
            </summary>
        </member>
        <member name="M:Edge.Tools.Random.IRandom.NextFloatBetween(System.Single,System.Single)">
            <summary>
            Returns the next random float between values.
            </summary>
        </member>
        <member name="M:Edge.Tools.Random.IRandom.NextSignedFloat">
            <summary>
            Returns the next random signed float (-1 - 1).
            </summary>
        </member>
        <member name="M:Edge.Tools.Random.IRandom.NextSignedSin">
            <summary>
            Returns the next random signed float using sin spread(-1 - 1).
            </summary>
        </member>
        <member name="M:Edge.Tools.Random.IRandom.NextSignedReverseSin">
            <summary>
            Returns the next random signed float using reverse sin spread(-1 - 1).
            Spread is strong in the edges and weak in the middle (0 - range).
            </summary>
        </member>
        <member name="M:Edge.Tools.Random.IRandom.SinRandom">
            <summary>
              Returns value between 0-1 with more spread to the ends by using Sin method to convert random numbers.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Random.IRandom.NextInt(System.Int32,System.Int32)">
            <summary>
              returns next random integer
            </summary>
            <param name = "minValue">minimum value of the integer</param>
            <param name = "maxValue">maximum value of the integer</param>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Random.IRandom.Next(System.Int32)">
            <summary>
             returns next random integer [0, UppedBoud[, useful for selecting from arrays
            </summary>
            <param name = "minValue">minimum value of the integer</param>
            <param name = "upperBound">upper bound value of the integer</param>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Random.IRandom.Next(System.Int32,System.Int32)">
            <summary>
             returns next random integer [minValue, UppedBoud[, useful for selecting from arrays
            </summary>
            <param name = "minValue">minimum value of the integer</param>
            <param name = "upperBound">upper bound value of the integer</param>
            <returns></returns>
        </member>
        <member name="M:Edge.Tools.Reflection.CopyData.CopyDataMethod`2.#ctor(System.Func{`0,`1,System.Boolean},System.Func{`1,`0,System.Boolean})">
            <summary>
            Create new instance with methods to copy data.
            </summary>
            <param name="copyDataTo"> return true if changed</param>
            <param name="reverseCopyDataTo"> return true if changed</param>
        </member>
        <member name="T:Edge.Tools.Threading.AbortableTask">
            <summary>
            Task that can be forcibly aborted.
            </summary>
        </member>
        <member name="M:Edge.Tools.Threading.AbortableTask.StartNew(System.Action,System.Threading.CancellationToken,System.Action{System.Exception},System.String)">
            <summary>Creates and starts a Task with given error handler. Default usage of ErrorManager is optional.</summary>
        </member>
        <member name="M:Edge.Tools.Threading.AbortableTask`1.StartNew``1(System.Func{``0},System.Threading.CancellationToken,System.Action{System.Exception},System.String)">
            <summary>Creates and starts a Task with given error handler. Default usage of ErrorManager is optional.</summary>
        </member>
        <member name="T:Edge.Tools.Time.TimeZonePeriod">
            <summary>
            Initialize this class with either contructor using UTC times
            or with InitializeUserTime method. 
            Use by advancing user time.
            Manually setting times will NOT update all the parameters properly.
            </summary>
        </member>
        <member name="M:Edge.Tools.Time.TimeZonePeriod.Steps(System.TimeSpan,System.Boolean,System.Boolean)">
            <summary>
            Not tested
            </summary>
        </member>
        <member name="T:Edge.Tools.Tools.CastTo`1">
            <summary>
            Class to cast to type <see cref="!:T"/>
            </summary>
            <typeparam name="T">Target type</typeparam>
        </member>
        <member name="M:Edge.Tools.Tools.CastTo`1.From``1(``0)">
            <summary>
            Casts <see cref="!:S"/> to <see cref="!:T"/>. 
            This does not cause boxing for value types. 
            Useful in generic methods
            </summary>
            <typeparam name="S">Source type to cast from. Usually a generic type.</typeparam>
        </member>
        <member name="T:Edge.Tools.Tools.Toggle">
            <summary>
            Provides a toggleable bool. Functions as an bool, 
            except when read as true, turns itself to false.
            </summary>
            <remarks>
            Use x.Value to get current value without toggling the value.
            Be careful however, as Toggle is a class and can thus be null.
            Safe way is to use: x?.Value ?? false
            </remarks>
        </member>
        <member name="T:Nikse.SubtitleEdit.Core.FastFileStream">
            <summary>
            Exposes a <see cref="T:System.IO.Stream"/> around a file, supporting synchronous read operations.
            </summary>
        </member>
        <member name="P:Nikse.SubtitleEdit.Core.FastFileStream.Length">
            <summary>
            Gets the length in bytes of the stream.
            </summary>
        </member>
        <member name="P:Nikse.SubtitleEdit.Core.FastFileStream.Position">
            <summary>
            Gets or sets the current position of the stream.
            </summary>
        </member>
        <member name="M:Nikse.SubtitleEdit.Core.FastFileStream.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Nikse.SubtitleEdit.Core.FastFileStream"/> class with the specified path.
            </summary>
            <param name="path">A relative or absolute path for the file that the current <see cref="T:Nikse.SubtitleEdit.Core.FastFileStream"/> object will encapsulate.</param>
        </member>
        <member name="M:Nikse.SubtitleEdit.Core.FastFileStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Sets the current position of this stream to the given value.
            </summary>
            <param name="offset">The point relative to <paramref name="origin"/> from which to begin seeking.</param>
            <param name="origin">Specifies the beginning, the end, or the current position as a reference point for origin, using a value of type <see cref="T:System.IO.SeekOrigin"/>.</param>
            <returns>The new position in the stream.</returns>
        </member>
        <member name="M:Nikse.SubtitleEdit.Core.FastFileStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads a block of bytes from the stream and writes the data in a given buffer.
            </summary>
            <param name="array">When this method returns, contains the specified byte array with the values between <paramref name="offset"/> and (<paramref name="offset"/> + <paramref name="count"/> - 1) replaced by the bytes read from the current source.</param>
            <param name="offset">The byte offset in <paramref name="array"/> at which the read bytes will be placed.</param>
            <param name="count">The maximum number of bytes to read.</param>
            <returns>The total number of bytes read into the buffer. This might be less than the number of bytes requested if that number of bytes are not currently available, or zero if the end of the stream is reached.</returns>
        </member>
        <member name="M:Nikse.SubtitleEdit.Core.FastFileStream.ReadByte">
            <summary>
            Reads a byte from the file and advances the read position one byte.
            </summary>
            <returns>The byte, cast to an Int32, or -1 if the end of the stream has been reached.</returns>
        </member>
        <member name="T:SEdge.Core.CustomColor">
            <summary>
            Describes a 32-bit packed color.
            </summary>
        </member>
        <member name="M:SEdge.Core.CustomColor.#ctor(SEdge.Core.CustomColor,System.Int32)">
            <summary>
            Constructs an RGBA color from a <see cref="T:SEdge.Core.CustomColor"/> and an alpha value.
            </summary>
            <param name="color">A <see cref="T:SEdge.Core.CustomColor"/> for RGB values of new <see cref="T:SEdge.Core.CustomColor"/> instance.</param>
            <param name="alpha">The alpha component value from 0 to 255.</param>
        </member>
        <member name="M:SEdge.Core.CustomColor.#ctor(SEdge.Core.CustomColor,System.Single)">
            <summary>
            Constructs an RGBA color from color and alpha value.
            </summary>
            <param name="color">A <see cref="T:SEdge.Core.CustomColor"/> for RGB values of new <see cref="T:SEdge.Core.CustomColor"/> instance.</param>
            <param name="alpha">Alpha component value from 0.0f to 1.0f.</param>
        </member>
        <member name="M:SEdge.Core.CustomColor.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Constructs an RGBA color from scalars which representing red, green and blue values. Alpha value will be opaque.
            </summary>
            <param name="r">Red component value from 0.0f to 1.0f.</param>
            <param name="g">Green component value from 0.0f to 1.0f.</param>
            <param name="b">Blue component value from 0.0f to 1.0f.</param>
        </member>
        <member name="M:SEdge.Core.CustomColor.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs an RGBA color from scalars which representing red, green and blue values. Alpha value will be opaque.
            </summary>
            <param name="r">Red component value from 0 to 255.</param>
            <param name="g">Green component value from 0 to 255.</param>
            <param name="b">Blue component value from 0 to 255.</param>
        </member>
        <member name="M:SEdge.Core.CustomColor.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs an RGBA color from scalars which representing red, green, blue and alpha values.
            </summary>
            <param name="r">Red component value from 0 to 255.</param>
            <param name="g">Green component value from 0 to 255.</param>
            <param name="b">Blue component value from 0 to 255.</param>
            <param name="alpha">Alpha component value from 0 to 255.</param>
        </member>
        <member name="M:SEdge.Core.CustomColor.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Constructs an RGBA color from scalars which representing red, green, blue and alpha values.
            </summary>
            <param name="r">Red component value from 0.0f to 1.0f.</param>
            <param name="g">Green component value from 0.0f to 1.0f.</param>
            <param name="b">Blue component value from 0.0f to 1.0f.</param>
            <param name="alpha">Alpha component value from 0.0f to 1.0f.</param>
        </member>
        <member name="P:SEdge.Core.CustomColor.B">
            <summary>
            Gets or sets the blue component.
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.G">
            <summary>
            Gets or sets the green component.
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.R">
            <summary>
            Gets or sets the red component.
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.A">
            <summary>
            Gets or sets the alpha component.
            </summary>
        </member>
        <member name="M:SEdge.Core.CustomColor.op_Equality(SEdge.Core.CustomColor,SEdge.Core.CustomColor)">
            <summary>
            Compares whether two <see cref="T:SEdge.Core.CustomColor"/> instances are equal.
            </summary>
            <param name="a"><see cref="T:SEdge.Core.CustomColor"/> instance on the left of the equal sign.</param>
            <param name="b"><see cref="T:SEdge.Core.CustomColor"/> instance on the right of the equal sign.</param>
            <returns><c>true</c> if the instances are equal; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:SEdge.Core.CustomColor.op_Inequality(SEdge.Core.CustomColor,SEdge.Core.CustomColor)">
            <summary>
            Compares whether two <see cref="T:SEdge.Core.CustomColor"/> instances are not equal.
            </summary>
            <param name="a"><see cref="T:SEdge.Core.CustomColor"/> instance on the left of the not equal sign.</param>
            <param name="b"><see cref="T:SEdge.Core.CustomColor"/> instance on the right of the not equal sign.</param>
            <returns><c>true</c> if the instances are not equal; <c>false</c> otherwise.</returns>	
        </member>
        <member name="M:SEdge.Core.CustomColor.GetHashCode">
            <summary>
            Gets the hash code of this <see cref="T:SEdge.Core.CustomColor"/>.
            </summary>
            <returns>Hash code of this <see cref="T:SEdge.Core.CustomColor"/>.</returns>
        </member>
        <member name="M:SEdge.Core.CustomColor.Equals(System.Object)">
            <summary>
            Compares whether current instance is equal to specified object.
            </summary>
            <param name="obj">The <see cref="T:SEdge.Core.CustomColor"/> to compare.</param>
            <returns><c>true</c> if the instances are equal; <c>false</c> otherwise.</returns>
        </member>
        <member name="P:SEdge.Core.CustomColor.TransparentBlack">
            <summary>
            TransparentBlack color (R:0,G:0,B:0,A:0).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Transparent">
            <summary>
            Transparent color (R:0,G:0,B:0,A:0).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.AliceBlue">
            <summary>
            AliceBlue color (R:240,G:248,B:255,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.AntiqueWhite">
            <summary>
            AntiqueWhite color (R:250,G:235,B:215,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Aqua">
            <summary>
            Aqua color (R:0,G:255,B:255,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Aquamarine">
            <summary>
            Aquamarine color (R:127,G:255,B:212,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Azure">
            <summary>
            Azure color (R:240,G:255,B:255,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Beige">
            <summary>
            Beige color (R:245,G:245,B:220,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Bisque">
            <summary>
            Bisque color (R:255,G:228,B:196,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Black">
            <summary>
            Black color (R:0,G:0,B:0,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.BlanchedAlmond">
            <summary>
            BlanchedAlmond color (R:255,G:235,B:205,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Blue">
            <summary>
            Blue color (R:0,G:0,B:255,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.BlueViolet">
            <summary>
            BlueViolet color (R:138,G:43,B:226,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Brown">
            <summary>
            Brown color (R:165,G:42,B:42,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.BurlyWood">
            <summary>
            BurlyWood color (R:222,G:184,B:135,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.CadetBlue">
            <summary>
            CadetBlue color (R:95,G:158,B:160,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Chartreuse">
            <summary>
            Chartreuse color (R:127,G:255,B:0,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Chocolate">
            <summary>
            Chocolate color (R:210,G:105,B:30,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Coral">
            <summary>
            Coral color (R:255,G:127,B:80,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.CornflowerBlue">
            <summary>
            CornflowerBlue color (R:100,G:149,B:237,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Cornsilk">
            <summary>
            Cornsilk color (R:255,G:248,B:220,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Crimson">
            <summary>
            Crimson color (R:220,G:20,B:60,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Cyan">
            <summary>
            Cyan color (R:0,G:255,B:255,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.DarkBlue">
            <summary>
            DarkBlue color (R:0,G:0,B:139,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.DarkCyan">
            <summary>
            DarkCyan color (R:0,G:139,B:139,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.DarkGoldenrod">
            <summary>
            DarkGoldenrod color (R:184,G:134,B:11,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.DarkGray">
            <summary>
            DarkGray color (R:169,G:169,B:169,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.DarkGreen">
            <summary>
            DarkGreen color (R:0,G:100,B:0,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.DarkKhaki">
            <summary>
            DarkKhaki color (R:189,G:183,B:107,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.DarkMagenta">
            <summary>
            DarkMagenta color (R:139,G:0,B:139,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.DarkOliveGreen">
            <summary>
            DarkOliveGreen color (R:85,G:107,B:47,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.DarkOrange">
            <summary>
            DarkOrange color (R:255,G:140,B:0,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.DarkOrchid">
            <summary>
            DarkOrchid color (R:153,G:50,B:204,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.DarkRed">
            <summary>
            DarkRed color (R:139,G:0,B:0,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.DarkSalmon">
            <summary>
            DarkSalmon color (R:233,G:150,B:122,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.DarkSeaGreen">
            <summary>
            DarkSeaGreen color (R:143,G:188,B:139,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.DarkSlateBlue">
            <summary>
            DarkSlateBlue color (R:72,G:61,B:139,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.DarkSlateGray">
            <summary>
            DarkSlateGray color (R:47,G:79,B:79,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.DarkTurquoise">
            <summary>
            DarkTurquoise color (R:0,G:206,B:209,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.DarkViolet">
            <summary>
            DarkViolet color (R:148,G:0,B:211,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.DeepPink">
            <summary>
            DeepPink color (R:255,G:20,B:147,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.DeepSkyBlue">
            <summary>
            DeepSkyBlue color (R:0,G:191,B:255,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.DimGray">
            <summary>
            DimGray color (R:105,G:105,B:105,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.DodgerBlue">
            <summary>
            DodgerBlue color (R:30,G:144,B:255,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Firebrick">
            <summary>
            Firebrick color (R:178,G:34,B:34,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.FloralWhite">
            <summary>
            FloralWhite color (R:255,G:250,B:240,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.ForestGreen">
            <summary>
            ForestGreen color (R:34,G:139,B:34,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Fuchsia">
            <summary>
            Fuchsia color (R:255,G:0,B:255,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Gainsboro">
            <summary>
            Gainsboro color (R:220,G:220,B:220,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.GhostWhite">
            <summary>
            GhostWhite color (R:248,G:248,B:255,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Gold">
            <summary>
            Gold color (R:255,G:215,B:0,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Goldenrod">
            <summary>
            Goldenrod color (R:218,G:165,B:32,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Gray">
            <summary>
            Gray color (R:128,G:128,B:128,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Green">
            <summary>
            Green color (R:0,G:128,B:0,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.GreenYellow">
            <summary>
            GreenYellow color (R:173,G:255,B:47,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Honeydew">
            <summary>
            Honeydew color (R:240,G:255,B:240,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.HotPink">
            <summary>
            HotPink color (R:255,G:105,B:180,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.IndianRed">
            <summary>
            IndianRed color (R:205,G:92,B:92,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Indigo">
            <summary>
            Indigo color (R:75,G:0,B:130,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Ivory">
            <summary>
            Ivory color (R:255,G:255,B:240,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Khaki">
            <summary>
            Khaki color (R:240,G:230,B:140,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Lavender">
            <summary>
            Lavender color (R:230,G:230,B:250,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.LavenderBlush">
            <summary>
            LavenderBlush color (R:255,G:240,B:245,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.LawnGreen">
            <summary>
            LawnGreen color (R:124,G:252,B:0,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.LemonChiffon">
            <summary>
            LemonChiffon color (R:255,G:250,B:205,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.LightBlue">
            <summary>
            LightBlue color (R:173,G:216,B:230,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.LightCoral">
            <summary>
            LightCoral color (R:240,G:128,B:128,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.LightCyan">
            <summary>
            LightCyan color (R:224,G:255,B:255,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.LightGoldenrodYellow">
            <summary>
            LightGoldenrodYellow color (R:250,G:250,B:210,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.LightGray">
            <summary>
            LightGray color (R:211,G:211,B:211,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.LightGreen">
            <summary>
            LightGreen color (R:144,G:238,B:144,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.LightPink">
            <summary>
            LightPink color (R:255,G:182,B:193,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.LightSalmon">
            <summary>
            LightSalmon color (R:255,G:160,B:122,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.LightSeaGreen">
            <summary>
            LightSeaGreen color (R:32,G:178,B:170,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.LightSkyBlue">
            <summary>
            LightSkyBlue color (R:135,G:206,B:250,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.LightSlateGray">
            <summary>
            LightSlateGray color (R:119,G:136,B:153,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.LightSteelBlue">
            <summary>
            LightSteelBlue color (R:176,G:196,B:222,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.LightYellow">
            <summary>
            LightYellow color (R:255,G:255,B:224,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Lime">
            <summary>
            Lime color (R:0,G:255,B:0,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.LimeGreen">
            <summary>
            LimeGreen color (R:50,G:205,B:50,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Linen">
            <summary>
            Linen color (R:250,G:240,B:230,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Magenta">
            <summary>
            Magenta color (R:255,G:0,B:255,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Maroon">
            <summary>
            Maroon color (R:128,G:0,B:0,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.MediumAquamarine">
            <summary>
            MediumAquamarine color (R:102,G:205,B:170,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.MediumBlue">
            <summary>
            MediumBlue color (R:0,G:0,B:205,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.MediumOrchid">
            <summary>
            MediumOrchid color (R:186,G:85,B:211,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.MediumPurple">
            <summary>
            MediumPurple color (R:147,G:112,B:219,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.MediumSeaGreen">
            <summary>
            MediumSeaGreen color (R:60,G:179,B:113,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.MediumSlateBlue">
            <summary>
            MediumSlateBlue color (R:123,G:104,B:238,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.MediumSpringGreen">
            <summary>
            MediumSpringGreen color (R:0,G:250,B:154,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.MediumTurquoise">
            <summary>
            MediumTurquoise color (R:72,G:209,B:204,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.MediumVioletRed">
            <summary>
            MediumVioletRed color (R:199,G:21,B:133,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.MidnightBlue">
            <summary>
            MidnightBlue color (R:25,G:25,B:112,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.MintCream">
            <summary>
            MintCream color (R:245,G:255,B:250,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.MistyRose">
            <summary>
            MistyRose color (R:255,G:228,B:225,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Moccasin">
            <summary>
            Moccasin color (R:255,G:228,B:181,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.MonoGameOrange">
            <summary>
            MonoGame orange theme color (R:231,G:60,B:0,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.NavajoWhite">
            <summary>
            NavajoWhite color (R:255,G:222,B:173,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Navy">
            <summary>
            Navy color (R:0,G:0,B:128,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.OldLace">
            <summary>
            OldLace color (R:253,G:245,B:230,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Olive">
            <summary>
            Olive color (R:128,G:128,B:0,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.OliveDrab">
            <summary>
            OliveDrab color (R:107,G:142,B:35,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Orange">
            <summary>
            Orange color (R:255,G:165,B:0,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.OrangeRed">
            <summary>
            OrangeRed color (R:255,G:69,B:0,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Orchid">
            <summary>
            Orchid color (R:218,G:112,B:214,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.PaleGoldenrod">
            <summary>
            PaleGoldenrod color (R:238,G:232,B:170,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.PaleGreen">
            <summary>
            PaleGreen color (R:152,G:251,B:152,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.PaleTurquoise">
            <summary>
            PaleTurquoise color (R:175,G:238,B:238,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.PaleVioletRed">
            <summary>
            PaleVioletRed color (R:219,G:112,B:147,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.PapayaWhip">
            <summary>
            PapayaWhip color (R:255,G:239,B:213,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.PeachPuff">
            <summary>
            PeachPuff color (R:255,G:218,B:185,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Peru">
            <summary>
            Peru color (R:205,G:133,B:63,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Pink">
            <summary>
            Pink color (R:255,G:192,B:203,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Plum">
            <summary>
            Plum color (R:221,G:160,B:221,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.PowderBlue">
            <summary>
            PowderBlue color (R:176,G:224,B:230,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Purple">
            <summary>
             Purple color (R:128,G:0,B:128,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Red">
            <summary>
            Red color (R:255,G:0,B:0,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.RosyBrown">
            <summary>
            RosyBrown color (R:188,G:143,B:143,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.RoyalBlue">
            <summary>
            RoyalBlue color (R:65,G:105,B:225,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.SaddleBrown">
            <summary>
            SaddleBrown color (R:139,G:69,B:19,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Salmon">
            <summary>
            Salmon color (R:250,G:128,B:114,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.SandyBrown">
            <summary>
            SandyBrown color (R:244,G:164,B:96,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.SeaGreen">
            <summary>
            SeaGreen color (R:46,G:139,B:87,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.SeaShell">
            <summary>
            SeaShell color (R:255,G:245,B:238,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Sienna">
            <summary>
            Sienna color (R:160,G:82,B:45,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Silver">
            <summary>
            Silver color (R:192,G:192,B:192,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.SkyBlue">
            <summary>
            SkyBlue color (R:135,G:206,B:235,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.SlateBlue">
            <summary>
            SlateBlue color (R:106,G:90,B:205,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.SlateGray">
            <summary>
            SlateGray color (R:112,G:128,B:144,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Snow">
            <summary>
            Snow color (R:255,G:250,B:250,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.SpringGreen">
            <summary>
            SpringGreen color (R:0,G:255,B:127,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.SteelBlue">
            <summary>
            SteelBlue color (R:70,G:130,B:180,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Tan">
            <summary>
            Tan color (R:210,G:180,B:140,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Teal">
            <summary>
            Teal color (R:0,G:128,B:128,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Thistle">
            <summary>
            Thistle color (R:216,G:191,B:216,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Tomato">
            <summary>
            Tomato color (R:255,G:99,B:71,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Turquoise">
            <summary>
            Turquoise color (R:64,G:224,B:208,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Violet">
            <summary>
            Violet color (R:238,G:130,B:238,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Wheat">
            <summary>
            Wheat color (R:245,G:222,B:179,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.White">
            <summary>
            White color (R:255,G:255,B:255,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.WhiteSmoke">
            <summary>
            WhiteSmoke color (R:245,G:245,B:245,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.Yellow">
            <summary>
            Yellow color (R:255,G:255,B:0,A:255).
            </summary>
        </member>
        <member name="P:SEdge.Core.CustomColor.YellowGreen">
            <summary>
            YellowGreen color (R:154,G:205,B:50,A:255).
            </summary>
        </member>
        <member name="M:SEdge.Core.CustomColor.Lerp(SEdge.Core.CustomColor,SEdge.Core.CustomColor,System.Single)">
            <summary>
            Performs linear interpolation of <see cref="T:SEdge.Core.CustomColor"/>.
            </summary>
            <param name="value1">Source <see cref="T:SEdge.Core.CustomColor"/>.</param>
            <param name="value2">Destination <see cref="T:SEdge.Core.CustomColor"/>.</param>
            <param name="amount">Interpolation factor.</param>
            <returns>Interpolated <see cref="T:SEdge.Core.CustomColor"/>.</returns>
        </member>
        <member name="M:SEdge.Core.CustomColor.LerpPrecise(SEdge.Core.CustomColor,SEdge.Core.CustomColor,System.Single)">
            <summary>
            Performs linear interpolation of <see cref="T:SEdge.Core.CustomColor"/> using <see cref="M:SEdge.Core.Maths.MathHelper.LerpPrecise(System.Single,System.Single,System.Single)"/> on MathHelper.
            Less efficient but more precise compared to <see cref="M:SEdge.Core.CustomColor.Lerp(SEdge.Core.CustomColor,SEdge.Core.CustomColor,System.Single)"/>.
            See remarks section of <see cref="M:SEdge.Core.Maths.MathHelper.LerpPrecise(System.Single,System.Single,System.Single)"/> on MathHelper for more info.
            </summary>
            <param name="value1">Source <see cref="T:SEdge.Core.CustomColor"/>.</param>
            <param name="value2">Destination <see cref="T:SEdge.Core.CustomColor"/>.</param>
            <param name="amount">Interpolation factor.</param>
            <returns>Interpolated <see cref="T:SEdge.Core.CustomColor"/>.</returns>
        </member>
        <member name="M:SEdge.Core.CustomColor.Multiply(SEdge.Core.CustomColor,System.Single)">
            <summary>
            Multiply <see cref="T:SEdge.Core.CustomColor"/> by value.
            </summary>
            <param name="value">Source <see cref="T:SEdge.Core.CustomColor"/>.</param>
            <param name="scale">Multiplicator.</param>
            <returns>Multiplication result.</returns>
        </member>
        <member name="M:SEdge.Core.CustomColor.op_Multiply(SEdge.Core.CustomColor,System.Single)">
            <summary>
            Multiply <see cref="T:SEdge.Core.CustomColor"/> by value.
            </summary>
            <param name="value">Source <see cref="T:SEdge.Core.CustomColor"/>.</param>
            <param name="scale">Multiplicator.</param>
            <returns>Multiplication result.</returns>
        </member>
        <member name="P:SEdge.Core.CustomColor.PackedValue">
            <summary>
            Gets or sets packed value of this <see cref="T:SEdge.Core.CustomColor"/>.
            </summary>
        </member>
        <member name="M:SEdge.Core.CustomColor.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> representation of this <see cref="T:SEdge.Core.CustomColor"/> in the format:
            {R:[red] G:[green] B:[blue] A:[alpha]}
            </summary>
            <returns><see cref="T:System.String"/> representation of this <see cref="T:SEdge.Core.CustomColor"/>.</returns>
        </member>
        <member name="M:SEdge.Core.CustomColor.FromNonPremultiplied(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Translate a non-premultipled alpha <see cref="T:SEdge.Core.CustomColor"/> to a <see cref="T:SEdge.Core.CustomColor"/> that contains premultiplied alpha.
            </summary>
            <param name="r">Red component value.</param>
            <param name="g">Green component value.</param>
            <param name="b">Blue component value.</param>
            <param name="a">Alpha component value.</param>
            <returns>A <see cref="T:SEdge.Core.CustomColor"/> which contains premultiplied alpha data.</returns>
        </member>
        <member name="M:SEdge.Core.CustomColor.Equals(SEdge.Core.CustomColor)">
            <summary>
            Compares whether current instance is equal to specified <see cref="T:SEdge.Core.CustomColor"/>.
            </summary>
            <param name="other">The <see cref="T:SEdge.Core.CustomColor"/> to compare.</param>
            <returns><c>true</c> if the instances are equal; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:SEdge.Core.Maths.MathHelper.Barycentric(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Returns the Cartesian coordinate for one axis of a point that is defined by a given triangle and two normalized barycentric (areal) coordinates.
            </summary>
            <param name="value1">The coordinate on one axis of vertex 1 of the defining triangle.</param>
            <param name="value2">The coordinate on the same axis of vertex 2 of the defining triangle.</param>
            <param name="value3">The coordinate on the same axis of vertex 3 of the defining triangle.</param>
            <param name="amount1">The normalized barycentric (areal) coordinate b2, equal to the weighting factor for vertex 2, the coordinate of which is specified in value2.</param>
            <param name="amount2">The normalized barycentric (areal) coordinate b3, equal to the weighting factor for vertex 3, the coordinate of which is specified in value3.</param>
            <returns>Cartesian coordinate of the specified point with respect to the axis being used.</returns>
        </member>
        <member name="M:SEdge.Core.Maths.MathHelper.CatmullRom(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Performs a Catmull-Rom interpolation using the specified positions.
            </summary>
            <param name="value1">The first position in the interpolation.</param>
            <param name="value2">The second position in the interpolation.</param>
            <param name="value3">The third position in the interpolation.</param>
            <param name="value4">The fourth position in the interpolation.</param>
            <param name="amount">Weighting factor.</param>
            <returns>A position that is the result of the Catmull-Rom interpolation.</returns>
        </member>
        <member name="M:SEdge.Core.Maths.MathHelper.Clamp(System.Double,System.Double,System.Double)">
            <summary>
            Restricts a value to be within a specified range.
            </summary>
            <param name="value">The value to clamp.</param>
            <param name="min">The minimum value. If <c>value</c> is less than <c>min</c>, <c>min</c> will be returned.</param>
            <param name="max">The maximum value. If <c>value</c> is greater than <c>max</c>, <c>max</c> will be returned.</param>
            <returns>The clamped value.</returns>
        </member>
        <member name="M:SEdge.Core.Maths.MathHelper.Clamp(System.Single,System.Single,System.Single)">
            <summary>
            Restricts a value to be within a specified range.
            </summary>
            <param name="value">The value to clamp.</param>
            <param name="min">The minimum value. If <c>value</c> is less than <c>min</c>, <c>min</c> will be returned.</param>
            <param name="max">The maximum value. If <c>value</c> is greater than <c>max</c>, <c>max</c> will be returned.</param>
            <returns>The clamped value.</returns>
        </member>
        <member name="M:SEdge.Core.Maths.MathHelper.Clamp(System.Byte,System.Byte,System.Byte)">
            <summary>
            Restricts a value to be within a specified range.
            </summary>
            <param name="value">The value to clamp.</param>
            <param name="min">The minimum value. If <c>value</c> is less than <c>min</c>, <c>min</c> will be returned.</param>
            <param name="max">The maximum value. If <c>value</c> is greater than <c>max</c>, <c>max</c> will be returned.</param>
            <returns>The clamped value.</returns>
        </member>
        <member name="M:SEdge.Core.Maths.MathHelper.Clamp(System.Int32,System.Int32,System.Int32)">
            <summary>
            Restricts a value to be within a specified range.
            </summary>
            <param name="value">The value to clamp.</param>
            <param name="min">The minimum value. If <c>value</c> is less than <c>min</c>, <c>min</c> will be returned.</param>
            <param name="max">The maximum value. If <c>value</c> is greater than <c>max</c>, <c>max</c> will be returned.</param>
            <returns>The clamped value.</returns>
        </member>
        <member name="M:SEdge.Core.Maths.MathHelper.Difference(System.Single,System.Single)">
            <summary>
            Calculates the absolute value of the difference of two values.
            </summary>
        </member>
        <member name="M:SEdge.Core.Maths.MathHelper.Hermite(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Performs a Hermite spline interpolation.
            </summary>
            <param name="value1">Source position.</param>
            <param name="tangent1">Source tangent.</param>
            <param name="value2">Source position.</param>
            <param name="tangent2">Source tangent.</param>
            <param name="amount">Weighting factor.</param>
            <returns>The result of the Hermite spline interpolation.</returns>
        </member>
        <member name="M:SEdge.Core.Maths.MathHelper.Lerp(System.Single,System.Single,System.Single)">
            <summary>
            Linearly interpolates between two values.
            </summary>
            <param name="value1">Source value.</param>
            <param name="value2">Destination value.</param>
            <param name="amount">Value between 0 and 1 indicating the weight of value2.</param>
            <returns>Interpolated value.</returns> 
            <remarks>This method performs the linear interpolation based on the following formula:
            <code>value1 + (value2 - value1) * amount</code>.
            Passing amount a value of 0 will cause value1 to be returned, a value of 1 will cause value2 to be returned.
            See <see cref="M:SEdge.Core.Maths.MathHelper.LerpPrecise(System.Single,System.Single,System.Single)"/> for a less efficient version with more precision around edge cases.
            </remarks>
        </member>
        <member name="M:SEdge.Core.Maths.MathHelper.LerpPrecise(System.Single,System.Single,System.Single)">
            <summary>
            Linearly interpolates between two values.
            This method is a less efficient, more precise version of <see cref="M:SEdge.Core.Maths.MathHelper.Lerp(System.Single,System.Single,System.Single)"/>.
            See remarks for more info.
            </summary>
            <param name="value1">Source value.</param>
            <param name="value2">Destination value.</param>
            <param name="amount">Value between 0 and 1 indicating the weight of value2.</param>
            <returns>Interpolated value.</returns>
            <remarks>This method performs the linear interpolation based on the following formula:
            <code>((1 - amount) * value1) + (value2 * amount)</code>.
            Passing amount a value of 0 will cause value1 to be returned, a value of 1 will cause value2 to be returned.
            This method does not have the floating point precision issue that <see cref="M:SEdge.Core.Maths.MathHelper.Lerp(System.Single,System.Single,System.Single)"/> has.
            i.e. If there is a big gap between value1 and value2 in magnitude (e.g. value1=10000000000000000, value2=1),
            right at the edge of the interpolation range (amount=1), <see cref="M:SEdge.Core.Maths.MathHelper.Lerp(System.Single,System.Single,System.Single)"/> will return 0 (whereas it should return 1).
            This also holds for value1=10^17, value2=10; value1=10^18,value2=10^2... so on.
            For an in depth explanation of the issue, see below references:
            Relevant Wikipedia Article: https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support
            Relevant StackOverflow Answer: http://stackoverflow.com/questions/4353525/floating-point-linear-interpolation#answer-23716956
            </remarks>
        </member>
        <member name="M:SEdge.Core.Maths.MathHelper.Max(System.Single,System.Single)">
            <summary>
            Returns the greater of two values.
            </summary>
            <param name="value1">Source value.</param>
            <param name="value2">Source value.</param>
            <returns>The greater value.</returns>
        </member>
        <member name="M:SEdge.Core.Maths.MathHelper.Max(System.Int32,System.Int32)">
            <summary>
            Returns the greater of two values.
            </summary>
            <param name="value1">Source value.</param>
            <param name="value2">Source value.</param>
            <returns>The greater value.</returns>
        </member>
        <member name="M:SEdge.Core.Maths.MathHelper.Min(System.Single,System.Single)">
            <summary>
            Returns the lesser of two values.
            </summary>
            <param name="value1">Source value.</param>
            <param name="value2">Source value.</param>
            <returns>The lesser value.</returns>
        </member>
        <member name="M:SEdge.Core.Maths.MathHelper.Min(System.Int32,System.Int32)">
            <summary>
            Returns the lesser of two values.
            </summary>
            <param name="value1">Source value.</param>
            <param name="value2">Source value.</param>
            <returns>The lesser value.</returns>
        </member>
        <member name="M:SEdge.Core.Maths.MathHelper.SmoothStep(System.Single,System.Single,System.Single)">
            <summary>
            Interpolates between two values using a cubic equation.
            </summary>
            <param name="value1">Source value.</param>
            <param name="value2">Source value.</param>
            <param name="amount">Weighting value.</param>
            <returns>Interpolated value.</returns>
        </member>
        <member name="M:SEdge.Core.Maths.MathHelper.ToDegrees(System.Single)">
            <summary>
            Converts radians to degrees.
            </summary>
            <param name="radians">The angle in radians.</param>
            <returns>The angle in degrees.</returns>
            <remarks>
            This method uses double precission internally,
            though it returns single float
            Factor = 180 / pi
            </remarks>
        </member>
        <member name="M:SEdge.Core.Maths.MathHelper.ToRadians(System.Single)">
            <summary>
            Converts degrees to radians.
            </summary>
            <param name="degrees">The angle in degrees.</param>
            <returns>The angle in radians.</returns>
            <remarks>
            This method uses double precission internally,
            though it returns single float
            Factor = pi / 180
            </remarks>
        </member>
        <member name="M:SEdge.Core.Maths.MathHelper.WrapAngle(System.Single)">
            <summary>
            Reduces a given angle to a value between π and -π.
            </summary>
            <param name="angle">The angle to reduce, in radians.</param>
            <returns>The new angle, in radians.</returns>
        </member>
        <member name="M:SEdge.Core.Maths.MathHelper.IsPowerOfTwo(System.Int32)">
            <summary>
            Determines if value is powered by two.
            </summary>
            <param name="value">A value.</param>
            <returns><c>true</c> if <c>value</c> is powered by two; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:SEdge.Core.Maths.MathHelper.NormalizeRotation(System.Double@)">
            <summary>
            Converts to single positive value
            </summary>
            <param name = "angle"></param>
        </member>
        <member name="M:SEdge.Core.Maths.MathHelper.InverseLerp(System.Double,System.Double,System.Double)">
            <summary>
            Inverses the lerp.
            </summary>
            <param name="value">The value between min and max values.</param>
            <param name="minValue">The min value.</param>
            <param name="maxValue">The max value.</param>
            <returns> 0 - 1 based on value, min and max</returns>
        </member>
        <member name="M:SEdge.Core.Maths.MathHelper.SinLerp(System.Double,System.Double,System.Double)">
            <summary>
              Allows smoother transition between angles or position than normal lerp
            </summary>
            <param name = "value1">The value1.</param>
            <param name = "value2">The value2.</param>
            <param name = "amount">The amount.</param>
            <returns></returns>
        </member>
        <member name="M:SEdge.Core.Maths.MathHelper.HalfSinLerp(System.Double,System.Double,System.Double)">
            <summary>
              Allows smoother transition between angles or position than normal lerp.
            Starts at value 1
            </summary>
            <param name = "value1">The value1.</param>
            <param name = "value2">The value2.</param>
            <param name = "amount">The amount.</param>
            <returns></returns>
        </member>
        <member name="M:SEdge.Core.Maths.MathHelper.TimeMultiply(System.TimeSpan,System.Single)">
            <summary>
              Multiplies a time value with a value
            </summary>
        </member>
        <member name="M:SEdge.Core.Maths.MathHelper.TimeMultiply(System.TimeSpan,System.Double)">
            <summary>
              Multiplies a time value with a value
            </summary>
        </member>
        <member name="M:SEdge.Core.Maths.MathHelper.TimespanToFloat(System.TimeSpan)">
            <summary>
            Converts Timespan to double.
            </summary>
            <param name="time">The time.</param>
            <returns></returns>
        </member>
        <member name="M:SEdge.Core.Maths.MathHelper.QuadraticEquationPositive(System.Double,System.Double,System.Double)">
            <summary>
            Calculates the quadratic equation giving the positive or higher result (if no positive value is found).
            </summary>
            <param name="a">A.</param>
            <param name="b">The b.</param>
            <param name="c">The c.</param>
            <returns></returns>
        </member>
        <member name="M:SEdge.Core.Maths.MathHelper.GetSmallest(System.Double[])">
            <summary>
                Gets the smallest index from array.
            </summary>
            <param name="value">The values.</param>
            <returns></returns>
        </member>
        <member name="M:SEdge.Core.Maths.MathHelper.GetLargest(System.Double[])">
            <summary>
                Gets the largest index from array.
            </summary>
            <param name="value">The values.</param>
            <returns></returns>
        </member>
        <member name="M:SEdge.Core.Texts.TextHelper.AddNulls(System.String)">
            <summary>
            Adds the nulls to string so that it has at least 2 numbers.
            </summary>
            <param name="text">The text.</param>
            <returns></returns>
        </member>
        <member name="M:SEdge.Core.Texts.TextHelper.AddNulls(System.String,System.Int32)">
            <summary>
            Adds the nulls to string so that it has at least x numbers.
            </summary>
            <param name="text">The text.</param>
            <param name="amount">amount</param>
            <returns></returns>
        </member>
        <member name="M:SEdge.Core.Texts.TextHelper.AddTexts(System.String,System.String,System.Int32)">
            <summary>
            Adds the texts to the end of the string.
            </summary>
        </member>
        <member name="M:SEdge.Core.Texts.TextHelper.DateTimeToTextHours(System.Int64)">
            <summary>
            Dates the time to text as hours and minutes.
            </summary>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:SEdge.Core.Texts.TextHelper.GetNumberOfLines(System.String)">
            <summary>
            Gets the number of lines base on the amount of '\n'.
            </summary>
        </member>
        <member name="T:NanoJpegResult">
            <summary>
            nj_result_t: Result codes for njDecode().
            </summary>
        </member>
        <member name="F:NanoJpegResult.NJ_OK">
            <summary>
            no error, decoding successful
            </summary>
        </member>
        <member name="F:NanoJpegResult.NJ_NO_JPEG">
            <summary>
            not a JPEG file
            </summary>
        </member>
        <member name="F:NanoJpegResult.NJ_UNSUPPORTED">
            <summary>
            unsupported format
            </summary>
        </member>
        <member name="F:NanoJpegResult.NJ_OUT_OF_MEM">
            <summary>
            out of memory
            </summary>
        </member>
        <member name="F:NanoJpegResult.NJ_INTERNAL_ERR">
            <summary>
            internal error
            </summary>
        </member>
        <member name="F:NanoJpegResult.NJ_SYNTAX_ERROR">
            <summary>
            syntax error
            </summary>
        </member>
        <member name="F:NanoJpegResult.__NJ_FINISHED">
            <summary>
            used internally, will never be reported
            </summary>
        </member>
    </members>
</doc>
